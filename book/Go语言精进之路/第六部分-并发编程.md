# 并发编程

## 31 优先考虑并发设计

> 并发不是并行，并发关乎结构，并行关乎执行。——Rob Pike，Go 语言之父

要想充分利用多核的强大计算能力，一般有两种方案：

- **并行**方案：在处理器核数充足的情况下启动多个单线程应用的实例，这样每个实例“运行”在一个核上，尽可能多地利用多核计算资源。
- **并发**方案：并发就是重新做应用结构设计，即将应用分解成多个在基本执行单元中执行的，可能有一定关联关系的代码片段。

Go 语言的设计哲学之一是“原生并发，轻量高效”。Go 并未使用操作系统线程作为承载分解后的代码片段的基本执行单元，而是实现了 goroutine 这一**由 Go 运行时负责调度的用户层轻量级线程**为并发程序设计提供原生支持。goroutine 相比传统操作系统线程而言具有如下优势：

- 资源占用小，每个 goroutine 的初始栈大小仅为 2KB；
- 由 Go 运行时而不是操作系统调度，goroutine 上下文切换代价较小；
- 语言原生支持：goroutine 由 go 关键字接函数或方法创建，函数或方法返回即表示 goroutine 退出，开发体验更佳；
- 语言内置 channel 作为 goroutine 间通信原语，为并发设计提供强大支撑。

Go 语言是面向并发而生的。因此，在应用的结构设计阶段，**Go 的惯例是优先考虑并发设计**。这样做更多是考虑到随着外界环境的变化，经过并发设计的 Go 应用可以更好、更自然地适应**规模化**。

案例-模拟机场安检：

- [顺序设计](https://github.com/bigwhite/GoProgrammingFromBeginnerToMaster/blob/main/chapter6/sources/concurrency-design-airport-securitycheck-1.go)
- [并行方案](https://github.com/bigwhite/GoProgrammingFromBeginnerToMaster/blob/main/chapter6/sources/concurrency-design-airport-securitycheck-2.go)
- [并发方案](https://github.com/bigwhite/GoProgrammingFromBeginnerToMaster/blob/main/chapter6/sources/concurrency-design-airport-securitycheck-3.go)

```GO
const (
   idCheckTmCost   = 60
   bodyCheckTmCost = 120
   xRayCheckTmCost = 180
)

func idCheck(id string) int {
   time.Sleep(time.Millisecond * time.Duration(idCheckTmCost))
   print("\tgoroutine-", id, "-idCheck: idCheck ok\n")
   return idCheckTmCost
}

func bodyCheck(id string) int {
   time.Sleep(time.Millisecond * time.Duration(bodyCheckTmCost))
   print("\tgoroutine-", id, "-bodyCheck: bodyCheck ok\n")
   return bodyCheckTmCost
}

func xRayCheck(id string) int {
   time.Sleep(time.Millisecond * time.Duration(xRayCheckTmCost))
   print("\tgoroutine-", id, "-xRayCheck: xRayCheck ok\n")
   return xRayCheckTmCost
}

func start(id string, f func(string) int, next chan<- struct{}) (chan<- struct{}, chan<- struct{}, <-chan int) {
   queue := make(chan struct{}, 10)
   quit := make(chan struct{})
   result := make(chan int)

   go func() {
      total := 0
      for {
         select {
         case <-quit:
            result <- total
            return
         case v := <-queue:
            total += f(id)
            if next != nil {
               next <- v
            }
         }
      }

   }()
   return queue, quit, result
}

func newAirportSecurityCheckChannel(id string, queue <-chan struct{}) {
   go func(id string) {
      print("goroutine-", id, ": airportSecurityCheckChannel is ready...\n")
      // start xRayCheck routine
      queue3, quit3, result3 := start(id, xRayCheck, nil)

      // start bodyCheck routine
      queue2, quit2, result2 := start(id, bodyCheck, queue3)

      // start idCheck routine
      queue1, quit1, result1 := start(id, idCheck, queue2)

      for {
         select {
         case v, ok := <-queue:
            if !ok {
               close(quit1)
               close(quit2)
               close(quit3)
               total := max(<-result1, <-result2, <-result3)
               print("goroutine-", id, ": airportSecurityCheckChannel time cost:", total, "\n")
               print("goroutine-", id, ": airportSecurityCheckChannel closed\n")
               return
            }
            queue1 <- v
         }
      }
   }(id)
}

func max(args ...int) int {
   n := 0
   for _, v := range args {
      if v > n {
         n = v
      }
   }
   return n
}

func main() {
   passengers := 30
   queue := make(chan struct{}, 30)
   newAirportSecurityCheckChannel("channel1", queue)
   newAirportSecurityCheckChannel("channel2", queue)
   newAirportSecurityCheckChannel("channel3", queue)

   time.Sleep(5 * time.Second) // 保证上述三个goroutine都已经处于ready状态
   for i := 0; i < passengers; i++ {
      queue <- struct{}{}
   }
   time.Sleep(5 * time.Second)
   close(queue) // 为了打印各通道的处理时长
   time.Sleep(1000 * time.Second)
}
```

## 参考

《Go 语言精进之路：从新手到高手的编程思想、方法和技巧》——白明