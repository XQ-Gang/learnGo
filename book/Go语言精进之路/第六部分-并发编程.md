# 并发编程

## 31 优先考虑并发设计

> 并发不是并行，并发关乎结构，并行关乎执行。——Rob Pike，Go 语言之父

要想充分利用多核的强大计算能力，一般有两种方案：

- **并行**方案：在处理器核数充足的情况下启动多个单线程应用的实例，这样每个实例“运行”在一个核上，尽可能多地利用多核计算资源。
- **并发**方案：并发就是重新做应用结构设计，即将应用分解成多个在基本执行单元中执行的，可能有一定关联关系的代码片段。

Go 语言的设计哲学之一是“原生并发，轻量高效”。Go 并未使用操作系统线程作为承载分解后的代码片段的基本执行单元，而是实现了 goroutine 这一**由 Go 运行时负责调度的用户层轻量级线程**为并发程序设计提供原生支持。goroutine 相比传统操作系统线程而言具有如下优势：

- 资源占用小，每个 goroutine 的初始栈大小仅为 2KB；
- 由 Go 运行时而不是操作系统调度，goroutine 上下文切换代价较小；
- 语言原生支持：goroutine 由 go 关键字接函数或方法创建，函数或方法返回即表示 goroutine 退出，开发体验更佳；
- 语言内置 channel 作为 goroutine 间通信原语，为并发设计提供强大支撑。

Go 语言是面向并发而生的。因此，在应用的结构设计阶段，**Go 的惯例是优先考虑并发设计**。这样做更多是考虑到随着外界环境的变化，经过并发设计的 Go 应用可以更好、更自然地适应**规模化**。

案例-模拟机场安检：

- [顺序设计](https://github.com/bigwhite/GoProgrammingFromBeginnerToMaster/blob/main/chapter6/sources/concurrency-design-airport-securitycheck-1.go)
- [并行方案](https://github.com/bigwhite/GoProgrammingFromBeginnerToMaster/blob/main/chapter6/sources/concurrency-design-airport-securitycheck-2.go)
- [并发方案](https://github.com/bigwhite/GoProgrammingFromBeginnerToMaster/blob/main/chapter6/sources/concurrency-design-airport-securitycheck-3.go)

```GO
const (
   idCheckTmCost   = 60
   bodyCheckTmCost = 120
   xRayCheckTmCost = 180
)

func idCheck(id string) int {
   time.Sleep(time.Millisecond * time.Duration(idCheckTmCost))
   print("\tgoroutine-", id, "-idCheck: idCheck ok\n")
   return idCheckTmCost
}

func bodyCheck(id string) int {
   time.Sleep(time.Millisecond * time.Duration(bodyCheckTmCost))
   print("\tgoroutine-", id, "-bodyCheck: bodyCheck ok\n")
   return bodyCheckTmCost
}

func xRayCheck(id string) int {
   time.Sleep(time.Millisecond * time.Duration(xRayCheckTmCost))
   print("\tgoroutine-", id, "-xRayCheck: xRayCheck ok\n")
   return xRayCheckTmCost
}

func start(id string, f func(string) int, next chan<- struct{}) (chan<- struct{}, chan<- struct{}, <-chan int) {
   queue := make(chan struct{}, 10)
   quit := make(chan struct{})
   result := make(chan int)

   go func() {
      total := 0
      for {
         select {
         case <-quit:
            result <- total
            return
         case v := <-queue:
            total += f(id)
            if next != nil {
               next <- v
            }
         }
      }

   }()
   return queue, quit, result
}

func newAirportSecurityCheckChannel(id string, queue <-chan struct{}) {
   go func(id string) {
      print("goroutine-", id, ": airportSecurityCheckChannel is ready...\n")
      // start xRayCheck routine
      queue3, quit3, result3 := start(id, xRayCheck, nil)

      // start bodyCheck routine
      queue2, quit2, result2 := start(id, bodyCheck, queue3)

      // start idCheck routine
      queue1, quit1, result1 := start(id, idCheck, queue2)

      for {
         select {
         case v, ok := <-queue:
            if !ok {
               close(quit1)
               close(quit2)
               close(quit3)
               total := max(<-result1, <-result2, <-result3)
               print("goroutine-", id, ": airportSecurityCheckChannel time cost:", total, "\n")
               print("goroutine-", id, ": airportSecurityCheckChannel closed\n")
               return
            }
            queue1 <- v
         }
      }
   }(id)
}

func max(args ...int) int {
   n := 0
   for _, v := range args {
      if v > n {
         n = v
      }
   }
   return n
}

func main() {
   passengers := 30
   queue := make(chan struct{}, 30)
   newAirportSecurityCheckChannel("channel1", queue)
   newAirportSecurityCheckChannel("channel2", queue)
   newAirportSecurityCheckChannel("channel3", queue)

   time.Sleep(5 * time.Second) // 保证上述三个goroutine都已经处于ready状态
   for i := 0; i < passengers; i++ {
      queue <- struct{}{}
   }
   time.Sleep(5 * time.Second)
   close(queue) // 为了打印各通道的处理时长
   time.Sleep(1000 * time.Second)
}
```

## 32 了解 goroutine 的调度原理

由于一个 goroutine 占用资源很少，一个 Go 程序中可以创建成千上万个并发的 goroutine。而将这些 goroutine 按照一定算法放到 CPU 上执行的程序就称为 **goroutine 调度器**。一个 Go 程序对于操作系统来说只是一个**用户层程序**，操作系统眼中只有线程，goroutine 的调度全要靠 Go 自己完成。

### goroutine 调度模型与演进过程

- **G-M 模型**：Go1.0 实现了一个简单的 goroutine 调度器。在这个调度器中，每个 goroutine 对应于运行时中的一个抽象结构——G (goroutine)，而被视作“物理 CPU”的操作系统线程则被抽象为另一个结构——M (machine)。重要不足：限制了 Go 并发程序的伸缩性，尤其是对那些有高吞吐或并行计算需求的服务程序。问题主要体现在：
  - 单一全局互斥锁和集中状态存储的存在导致所有 goroutine 导致所有 goroutine 相关操作（如创建、重新调度）都要上锁；
  - goroutine 传递问题：经常在 M 之间传递“可运行”的 goroutine 会导致调度延迟增大，带来额外的性能损耗；
  - 每个 M 都做内存缓存，导致内存占用过高，数据局部性较差；
  - 因系统调用而形成的频繁的工作线程阻塞和解除阻塞会带来额外的性能损耗。
- **G-P-M 模型**：Dmitry Vyukov 在 Go1.1 实现了 **G-P-M 调度模型**和 **work stealing 算法**，这个模型一直沿用至今。有人曾说过：“**计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。**”P 是一个“逻辑处理器”，每个 G 要想真正运行起来，首先需要被分配一个 P，即进入 P 的本地运行队列中，这里暂忽略全局运行队列那个环节。对于 G 来说，P 就是运行它的 CPU，可以说**在 G 的眼里只有 P**。但从 goroutine 调度器的视角来看，真正的 CPU 是 M，只有将 P 和 M 绑定才能让 P 的本地运行队列中的 G 真正运行起来。
- **抢占式调度**：G-P-M 模型不支持抢占式调度，这导致一旦某个 G 中出现死循环的代码逻辑，那么 G 将永久占用分配给它的 P 和 M，而位于同一个 P 中的其他 G 将得不到调度，出现“**饿死**”的情况。更为严重的是：当只有一个 P (GOMAXPROCS=1) 时，整个 Go 程序中的其他 G 都将“饿死”。于是 Dmitry Vyukov 又提出了“Go 抢占式调度器设计”，并在 Go1.2 版本中实现了抢占式调度。这个抢占式调度的原理是**在每个函数或方法的入口加上一段额外的代码，让运行时有机会检查是否需要执行抢占调度**。这种**协作式抢占调度**的解决方案只是局部解决了“饿死”问题，对于没有函数调用而是纯算法循环计算的 G，goroutine 调度器依然无法抢占。Go1.14 版本中加入了基于系统信号的 goroutine 抢占式调度机制，很大程度上解决了 goroutine “饿死”的问题。
- **NUMA 调度模型**：在 Go1.2 以后，Go 将重点放在了对 GC 低延迟的优化上，对调度器的优化和改进似乎不那么热心了，只是伴随着 GC 的改进而作了些小的改动。Dmitry Vyukov 在 2014 年 9 月提出了一个新的设计草案文档“NUMA - aware scheduler for Go”，作为对未来 goroutine 调度器演进方向的一个提案，不过这个提案至今也没有被列入开发计划。
- **其他优化**：Go 运行时已经实现了 **netpoller**，这使得即便 G 发起网络 I/O 操作也不会导致 M 被阻塞（仅阻塞 G），因而不会导致大量线程（M）被创建出来。但是对于常规文件的 I/O 操作一旦阻塞，那么线程（M）将进入挂起状态，等待 I/O 返回后被唤醒。这种情况下 P 将与挂起的 M 分离，再选择一个处于空闲状态（idle）的 M。如果此时没有空闲的 M，则会新创建一个 M（线程），这就是大量文件 I/O 操作会导致大量线程被创建的原因。Ian Lance Taylor 在 Go1.9 版本中增加了一个针对文件 I/O 的 **Poller**，它可以像 netpoller 那样，在 G 操作那些支持监听的（pollable）文件描述符时，仅阻塞 G，而不会阻塞 M。不过该功能依然对常规文件无效，常规文件是不支持监听的。但对于 goroutine 调度器而言，这也算是一个不小的进步了。

### goroutine 调度器原理的进一步理解

**G、P、M**：

- G：代表 goroutine，存储了 goroutine 的执行栈信息、goroutine 状态及 goroutine 的任务函数等。另外 G 对象是可以重用的；
- P：代表逻辑 processor，P 的数量决定了系统内最大可并行的 G 的数量（前提：系统的物理 CPU 核数 >= P 的数量）。P 中最有用的是其拥有的各种 G 对象队列、链表、一些缓存和状态；
- M：代表着真正的执行计算资源。在绑定有效的 P 后，进入一个调度循环；而调度循环的机制大致是从各种队列、P 的本地运行队列中获取 G，切换到 G 的执行栈上并执行 G 的函数，调用 goexit 做清理工作并回到 M。如此反复。M 并不保留 G 状态，这是 G 可以跨 M 调度的基础。

**G 被抢占调度**：Go 中没有时间片的概念。如果某个 G 没有进行系统调用、没有进行 I/O 操作、没有阻塞在一个 channel 操作上，那么 G 将被抢占调度。在 Go 程序启动时，运行时会启动一个名为 sysmon 的 M（一般称为监控线程），该 M 的特殊之处在于它无需绑定 P 即可运行。该 M 在整个 Go 程序的运行过程中至关重要，sysmon 每 20us ~ 10ms 启动一次，主要完成如下工作：

- 释放闲置超过 5 min 的 span 物理内存；
- 如果超过 2 分钟没有垃圾回收，强制执行；
- 将长时间未处理的 netpoll 结果添加到任务队列；
- 向长时间运行的 G 任务发出抢占调度；
- 收回因 syscall 长时间阻塞的 P。

**channel 阻塞或网络 I/O 情况下的调度**：如果 G 被阻塞在某个 channel 操作或网络 I/O 操作上，那么 G 会被放置到某个等待队列中，而 M 会尝试运行 P 的下一个可运行的 G。如果此时 P 没有可运行的 G 供 M 运行，那么 M 将解绑 P，并进入挂起状态。当 I/O 操作完成或 channel 操作完成，在等待队列中的 G 会被唤醒，标记为 runnable（可运行），并被放入某个 P 的队列中，绑定一个 M 后继续执行。

**系统调用阻塞情况下的调度**：如果 G 被阻塞在某个系统调用上，那么不仅 G 会阻塞，执行该 G 的 M 也会解绑 P（实质是被 sysmon 抢走了），与 G 一起进入阻塞状态。如果此时有空闲的 M，则 P 会与其绑定并继续执行其他 G；如果没有空闲的 M，但仍然有其他 G 要执行，那么就会创建一个新 M（线程）。当系统调用返回后，阻塞在该系统调用上的 G 会尝试获取一个可用的 P，如果有可用 P，之前运行该 G 的 M 将绑定 P 继续运行 G；如果没有可用的 P，那么 G 与 M 之间的关联将解除，同时 G 会被标记为 runnable，放入全局的运行队列中，等待调度器的再次调度。

## 参考

《Go 语言精进之路：从新手到高手的编程思想、方法和技巧》——白明