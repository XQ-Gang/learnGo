# 测试、性能剖析与调试

## 40 理解包内测试与包外测试的区别

**包内测试**：将测试代码放在与被测包同名的包中的测试方法。本质上是一种**面向实现的白盒测试**。

- 优势：测试代码可以访问该包下的所有符号；可以更为直接地构造测试数据和实施测试逻辑；更容易达到较高的测试覆盖率。
- 问题：测试代码自身需要经常性的维护；容易引起包循环引用。

**包外测试**：将测试代码放在名为被测包包名+"_test"的包中的测试方法。本质是一种**面向接口的黑盒测试**。

- 优势：包外测试代码与被测试包充分解耦，很少随着被测代码内部实现逻辑的调整而进行调整和维护。
- 问题：存在测试盲区，容易出现对被测试包的测试覆盖不足的情况。
- 惯用法：**安插后门**，在被测包下的 **export_test.go** 既不会被包含在正式产品代码中，又不包含任何测试代码，而仅被用于被测包的内部符号在测试阶段暴露给包外测试代码，或者定义一些辅助包外测试的代码，比如扩展被测包的方法集合。

**优先使用包外测试**：

- 包外测试更适合编写偏向**集成测试**的用例，它可以任意导入外部包，并测试与外部多个组件的交互。
- 当运用包外测试与包内测试共存的方式时，可考虑让包外测试和包内测试聚焦于不同的测试类型。

## 41 有层次地组织测试代码

**经典模式——平铺**：

- 所有测试平铺在顶层。
- 简单：没有额外的抽象，上手容易。
- 独立：每个测试函数都是独立的，互不关联，避免互相干扰。

**xUnit 家族模式**：

- 组织形式主要有测试套件（Test Suite）和测试用例（Test Case）两个层级。
- 一个测试工程（Test Project）由若干个测试套件组成，而每个测试套件又包含多个测试用例。
- Go1.7 加入了`t.Run("xxx", testXxx)`对 subtest 进行支持。
- 平铺模式下的 TestXxx 都改名为 testXxx，并作为测试套件对应的测试函数内部的子测试。

**测试固件**（Test Fixture）：一个人造的、确定性的环境，一个测试用例或一个测试套件在这个环境中进行测试，其测试结果时刻重复的。我们一般使用 `setUp` 和 `tearDown` 来代表测试固件的创建/设置与拆除/销毁的动作。常用场景：

- 将一组已知的特定数据加载到数据库中，测试结束后清除这些数据；
- 复制一组特定的已知文件，测试结束后清除这些文件；
- 创建伪对象（fake object）或模拟对象（mock object），并为这些对象设定测试时所需的特定数据和期望结果。

Go1.14 版本 testing 包增加了 `testing.Cleanup` 方法，为测试固件的销毁提供了包级原生的支持：

```Go
func setUp() func() {
    ...
    return func() {
        ...
    }
}

func TestXxx(t *testing.T) {
    t.Cleanup(setUp())
    ...
}
```

Go1.4 版本引入了 `TestMain`，使得**包级别测试固件**的创建和销毁有了正式的施展舞台。

有些时候，一些测试函数所需的测试固件是相同的，在平铺模式下为每个测试函数都单独创建/销毁一次测试固件就显得有些重复和冗余。在这样的情况下，我们可以尝试采用测试套件来减少测试固件的重复创建。

**小结**：在确定了将测试代码放入包内测试还是包外测试之后，我们在编写测试前，还要做好测试包内部测试代码的组织规划，建立起适合自己项目规模的测试代码层次体系。简单的测试可采用平铺模式，复杂的测试可借鉴 xUnit 的最佳实践，利用 subtest 建立包、测试套件、测试用例三级的测试代码组织形式，并利用 TestMain 和 testing.Cleanup 方法为各层次的测试代码建立测试固件。

## 参考

《Go 语言精进之路：从新手到高手的编程思想、方法和技巧》——白明