# 测试、性能剖析与调试

## 40 理解包内测试与包外测试的区别

**包内测试**：将测试代码放在与被测包同名的包中的测试方法。本质上是一种**面向实现的白盒测试**。

- 优势：测试代码可以访问该包下的所有符号；可以更为直接地构造测试数据和实施测试逻辑；更容易达到较高的测试覆盖率。
- 问题：测试代码自身需要经常性的维护；容易引起包循环引用。

**包外测试**：将测试代码放在名为被测包包名+"_test"的包中的测试方法。本质是一种**面向接口的黑盒测试**。

- 优势：包外测试代码与被测试包充分解耦，很少随着被测代码内部实现逻辑的调整而进行调整和维护。
- 问题：存在测试盲区，容易出现对被测试包的测试覆盖不足的情况。
- 惯用法：**安插后门**，在被测包下的 **export_test.go** 既不会被包含在正式产品代码中，又不包含任何测试代码，而仅被用于被测包的内部符号在测试阶段暴露给包外测试代码，或者定义一些辅助包外测试的代码，比如扩展被测包的方法集合。

**优先使用包外测试**：

- 包外测试更适合编写偏向**集成测试**的用例，它可以任意导入外部包，并测试与外部多个组件的交互。
- 当运用包外测试与包内测试共存的方式时，可考虑让包外测试和包内测试聚焦于不同的测试类型。

## 41 有层次地组织测试代码

**经典模式——平铺**：

- 所有测试平铺在顶层。
- 简单：没有额外的抽象，上手容易。
- 独立：每个测试函数都是独立的，互不关联，避免互相干扰。

**xUnit 家族模式**：

- 组织形式主要有测试套件（Test Suite）和测试用例（Test Case）两个层级。
- 一个测试工程（Test Project）由若干个测试套件组成，而每个测试套件又包含多个测试用例。
- Go1.7 加入了`t.Run("xxx", testXxx)`对 subtest 进行支持。
- 平铺模式下的 TestXxx 都改名为 testXxx，并作为测试套件对应的测试函数内部的子测试。

**测试固件**（Test Fixture）：一个人造的、确定性的环境，一个测试用例或一个测试套件在这个环境中进行测试，其测试结果时刻重复的。我们一般使用 `setUp` 和 `tearDown` 来代表测试固件的创建/设置与拆除/销毁的动作。常用场景：

- 将一组已知的特定数据加载到数据库中，测试结束后清除这些数据；
- 复制一组特定的已知文件，测试结束后清除这些文件；
- 创建伪对象（fake object）或模拟对象（mock object），并为这些对象设定测试时所需的特定数据和期望结果。

Go1.14 版本 testing 包增加了 `testing.Cleanup` 方法，为测试固件的销毁提供了包级原生的支持：

```Go
func setUp() func() {
    ...
    return func() {
        ...
    }
}

func TestXxx(t *testing.T) {
    t.Cleanup(setUp())
    ...
}
```

Go1.4 版本引入了 `TestMain`，使得**包级别测试固件**的创建和销毁有了正式的施展舞台。

有些时候，一些测试函数所需的测试固件是相同的，在平铺模式下为每个测试函数都单独创建/销毁一次测试固件就显得有些重复和冗余。在这样的情况下，我们可以尝试采用测试套件来减少测试固件的重复创建。

**小结**：在确定了将测试代码放入包内测试还是包外测试之后，我们在编写测试前，还要做好测试包内部测试代码的组织规划，建立起适合自己项目规模的测试代码层次体系。简单的测试可采用平铺模式，复杂的测试可借鉴 xUnit 的最佳实践，利用 subtest 建立包、测试套件、测试用例三级的测试代码组织形式，并利用 TestMain 和 testing.Cleanup 方法为各层次的测试代码建立测试固件。

## 42 优先编写表驱动的测试

Go 测试代码的一般逻辑：针对给定的输入数据，比较被测函数/方法返回的实际结果值与预期值，如有差异，则通过 testing 包提供的相关函数输出差异信息。

 表驱动测试优点：

- 简单和紧凑；
- 数据即测试；
- 结合子测试后，可单独运行某个数据项的测试。

表驱动测试实践中的注意事项：

- 表的实现方式：测试中使用的表可以使用自定义结构体的切片实现，也可以使用基于自定义结构体的其他集合类型（如map）来实现。但是使用 map 作为数据表时要注意，表内数据项的测试先后顺序是不确定的。
- 测试失败时的数据项的定位：通过输出数据表项在数据表中的偏移量来辅助定位；使用使用名字来区分不同的数据项。
- Errorf 还是 Fatalf：Errorf 不会中断当前的 goroutine 的执行，即便某个数据项导致了测试失败，测试依旧会继续执行下去；Fatalf 会终止测试执行。

## 43 使用 testdata 管理测试依赖的外部数据文件

测试固件是 Go 测试执行所需的上下文环境，其中测试依赖的外部数据文件就是一种常见的测试固件。在一些包含文件 I/O 的包的测试中，我们经常需要从外部数据文件中加载数据或向外部文件写入结果数据以满足测试固件的需求。

**testdata 目录**：Go 语言规定 Go 工具链将忽略名为 **testdata** 的目录。

- 开发者在编写测试时，就可以在名为 **testdata** 的目录下存放和管理测试代码依赖的数据文件。
- 我们还经常将预期结果数据保存在文件中并放置在 testdata 下，然后在测试代码中将被测对象输出的数据与这些预置在文件中的数据进行比较，一致则测试通过；反之，测试失败。

**golden 文件**：惯用法，实现了 testdata 目录下测试依赖的预期结果数据文件的数据采集和测试代码的融合。

- 带有 -update 命令参数的 go test 命令仅需在需要进行预期结果数据采集时才会执行，尤其是在因数据生成逻辑或类型结构定义发生变化，需要重新采集预期结果数据时。
- 要格外注意在每次重新采集预期结果后，对 golden 文件中的数据进行正确性检查，否则很容易出现预期结果数据不正确，但测试依然通过的情况。

```Go
var update = flag.Bool("update", false, "update .golden files")

if *update {
    ...
}
```

## 44 正确运用 fake、stub 和 mock 等辅助单元测试

> 你不需要一个真实的数据库来满足运行单元测试的需求。

越是接近业务层，被测代码对外部组件或服务依赖的可能性越大。但在开发测试环境，我们无法像在生产环境中那样，为测试提供真实运行的外部依赖。我们需要为这些被测代码提供其依赖的外部组件或服务的替身。

**fake：真实组件或服务的简化实现版替身**。使用 fake 替身进行测试的最常见理由是在测试环境无法构造被测代码所依赖的外部组件或服务，或者这些组件/服务有副作用，且不具备在测试前对返回结果进行预设置的能力。

**stub：对返回结果有一定预设控制能力的替身**。stub 替身增强了对替身返回结果的间接控制能力，这种控制可以通过测试前对调用结果预设置来实现。stub 替身通常仅针对计划之内的结果进行设置，对计划之外的请求也无能为力。

**mock：专用于行为观察和验证的替身**。它除了能提供测试前的预设置返回结果能力之外，还可以对 mock 替身对象在测试过程中的行为进行观察和验证。局限：mock 一般用作 Go 接口类型的实现的替身；一般需要通过第三方框架实现 mock 替身，Go 官方维护了一个 mock 框架——[gomock](https://github.com/golang/mock)，该框架通过代码生成的方式生成实现某接口的替身类型。

## 45 使用模糊测试让潜在 bug 无处遁形

> 模糊测试就是指半自动或自动地为程序提供非法的、非预期、随机的数据，并监控程序在这些输入数据下是否会出现崩溃、内置断言失败、内存泄漏、安全漏洞等情况。

Go1.5 版本发布的同时，Dmitry Vyukov 发布了 Go 语言模糊测试工具 **go-fuzz**。

**go-fuzz 的工作流程**：

1. 生成随机数据；
2. 将上述数据作为输入传递给北侧程序；
3. 观察是否有崩溃记录（crash），如果发现崩溃记录，则说明找到了潜在的 bug。

go-fuzz 采用的是**代码覆盖率引导的 fuzzing 算法**（Coverage-guided fuzzing）.

go-fuzz 的核心是**对语料库的输入数据如何进行变化**。go-fuzz 内部使用两种对语料库的输入数据进行变化的方法：突变（mutation）和改写（versify）。

- 突变是一种低级方法，主要是对语料库的字节进行小修改。
- 改写是比较先进的高级方法，它会学习文本的结构，对输入进行简单分析，识别出输入预料数据中各个部分的类型，比如数字、字母数字、列表、引用等，然后针对不同部分运用突变策略。

Go1.18 在标准工具链中开始支持 [fuzzing](https://go.dev/doc/fuzz/)。

官方教学：[Tutorial: Getting started with fuzzing](https://go.dev/doc/tutorial/fuzz)

小结：模糊测试最适合那些**处理复杂输入数据**的程序，比如文件格式解析、网络协议解析、人机交互界面入口等。模糊测试是软件测试技术的一个重要分支，与单元测试等互为补充，相辅相成。

## 参考

《Go 语言精进之路：从新手到高手的编程思想、方法和技巧》——白明