# 测试、性能剖析与调试

## 40 理解包内测试与包外测试的区别

**包内测试**：将测试代码放在与被测包同名的包中的测试方法。本质上是一种**面向实现的白盒测试**。

- 优势：测试代码可以访问该包下的所有符号；可以更为直接地构造测试数据和实施测试逻辑；更容易达到较高的测试覆盖率。
- 问题：测试代码自身需要经常性的维护；容易引起包循环引用。

**包外测试**：将测试代码放在名为被测包包名+"_test"的包中的测试方法。本质是一种**面向接口的黑盒测试**。

- 优势：包外测试代码与被测试包充分解耦，很少随着被测代码内部实现逻辑的调整而进行调整和维护。
- 问题：存在测试盲区，容易出现对被测试包的测试覆盖不足的情况。
- 惯用法：**安插后门**，在被测包下的 **export_test.go** 既不会被包含在正式产品代码中，又不包含任何测试代码，而仅被用于被测包的内部符号在测试阶段暴露给包外测试代码，或者定义一些辅助包外测试的代码，比如扩展被测包的方法集合。

**优先使用包外测试**：

- 包外测试更适合编写偏向**集成测试**的用例，它可以任意导入外部包，并测试与外部多个组件的交互。
- 当运用包外测试与包内测试共存的方式时，可考虑让包外测试和包内测试聚焦于不同的测试类型。

## 41 有层次地组织测试代码

**经典模式——平铺**：

- 所有测试平铺在顶层。
- 简单：没有额外的抽象，上手容易。
- 独立：每个测试函数都是独立的，互不关联，避免互相干扰。

**xUnit 家族模式**：

- 组织形式主要有测试套件（Test Suite）和测试用例（Test Case）两个层级。
- 一个测试工程（Test Project）由若干个测试套件组成，而每个测试套件又包含多个测试用例。
- Go1.7 加入了`t.Run("xxx", testXxx)`对 subtest 进行支持。
- 平铺模式下的 TestXxx 都改名为 testXxx，并作为测试套件对应的测试函数内部的子测试。

**测试固件**（Test Fixture）：一个人造的、确定性的环境，一个测试用例或一个测试套件在这个环境中进行测试，其测试结果时刻重复的。我们一般使用 `setUp` 和 `tearDown` 来代表测试固件的创建/设置与拆除/销毁的动作。常用场景：

- 将一组已知的特定数据加载到数据库中，测试结束后清除这些数据；
- 复制一组特定的已知文件，测试结束后清除这些文件；
- 创建伪对象（fake object）或模拟对象（mock object），并为这些对象设定测试时所需的特定数据和期望结果。

Go1.14 版本 testing 包增加了 `testing.Cleanup` 方法，为测试固件的销毁提供了包级原生的支持：

```Go
func setUp() func() {
    ...
    return func() {
        ...
    }
}

func TestXxx(t *testing.T) {
    t.Cleanup(setUp())
    ...
}
```

Go1.4 版本引入了 `TestMain`，使得**包级别测试固件**的创建和销毁有了正式的施展舞台。

有些时候，一些测试函数所需的测试固件是相同的，在平铺模式下为每个测试函数都单独创建/销毁一次测试固件就显得有些重复和冗余。在这样的情况下，我们可以尝试采用测试套件来减少测试固件的重复创建。

**小结**：在确定了将测试代码放入包内测试还是包外测试之后，我们在编写测试前，还要做好测试包内部测试代码的组织规划，建立起适合自己项目规模的测试代码层次体系。简单的测试可采用平铺模式，复杂的测试可借鉴 xUnit 的最佳实践，利用 subtest 建立包、测试套件、测试用例三级的测试代码组织形式，并利用 TestMain 和 testing.Cleanup 方法为各层次的测试代码建立测试固件。

## 42 优先编写表驱动的测试

Go 测试代码的一般逻辑：针对给定的输入数据，比较被测函数/方法返回的实际结果值与预期值，如有差异，则通过 testing 包提供的相关函数输出差异信息。

 表驱动测试优点：

- 简单和紧凑；
- 数据即测试；
- 结合子测试后，可单独运行某个数据项的测试。

表驱动测试实践中的注意事项：

- 表的实现方式：测试中使用的表可以使用自定义结构体的切片实现，也可以使用基于自定义结构体的其他集合类型（如map）来实现。但是使用 map 作为数据表时要注意，表内数据项的测试先后顺序是不确定的。
- 测试失败时的数据项的定位：通过输出数据表项在数据表中的偏移量来辅助定位；使用使用名字来区分不同的数据项。
- Errorf 还是 Fatalf：Errorf 不会中断当前的 goroutine 的执行，即便某个数据项导致了测试失败，测试依旧会继续执行下去；Fatalf 会终止测试执行。

## 43 使用 testdata 管理测试依赖的外部数据文件

测试固件是 Go 测试执行所需的上下文环境，其中测试依赖的外部数据文件就是一种常见的测试固件。在一些包含文件 I/O 的包的测试中，我们经常需要从外部数据文件中加载数据或向外部文件写入结果数据以满足测试固件的需求。

**testdata 目录**：Go 语言规定 Go 工具链将忽略名为 **testdata** 的目录。

- 开发者在编写测试时，就可以在名为 **testdata** 的目录下存放和管理测试代码依赖的数据文件。
- 我们还经常将预期结果数据保存在文件中并放置在 testdata 下，然后在测试代码中将被测对象输出的数据与这些预置在文件中的数据进行比较，一致则测试通过；反之，测试失败。

**golden 文件**：惯用法，实现了 testdata 目录下测试依赖的预期结果数据文件的数据采集和测试代码的融合。

- 带有 -update 命令参数的 go test 命令仅需在需要进行预期结果数据采集时才会执行，尤其是在因数据生成逻辑或类型结构定义发生变化，需要重新采集预期结果数据时。
- 要格外注意在每次重新采集预期结果后，对 golden 文件中的数据进行正确性检查，否则很容易出现预期结果数据不正确，但测试依然通过的情况。

```Go
var update = flag.Bool("update", false, "update .golden files")

if *update {
    ...
}
```

## 44 正确运用 fake、stub 和 mock 等辅助单元测试

> 你不需要一个真实的数据库来满足运行单元测试的需求。

越是接近业务层，被测代码对外部组件或服务依赖的可能性越大。但在开发测试环境，我们无法像在生产环境中那样，为测试提供真实运行的外部依赖。我们需要为这些被测代码提供其依赖的外部组件或服务的替身。

**fake：真实组件或服务的简化实现版替身**。使用 fake 替身进行测试的最常见理由是在测试环境无法构造被测代码所依赖的外部组件或服务，或者这些组件/服务有副作用，且不具备在测试前对返回结果进行预设置的能力。

**stub：对返回结果有一定预设控制能力的替身**。stub 替身增强了对替身返回结果的间接控制能力，这种控制可以通过测试前对调用结果预设置来实现。stub 替身通常仅针对计划之内的结果进行设置，对计划之外的请求也无能为力。

**mock：专用于行为观察和验证的替身**。它除了能提供测试前的预设置返回结果能力之外，还可以对 mock 替身对象在测试过程中的行为进行观察和验证。局限：mock 一般用作 Go 接口类型的实现的替身；一般需要通过第三方框架实现 mock 替身，Go 官方维护了一个 mock 框架——[gomock](https://github.com/golang/mock)，该框架通过代码生成的方式生成实现某接口的替身类型。

## 45 使用模糊测试让潜在 bug 无处遁形

> 模糊测试就是指半自动或自动地为程序提供非法的、非预期、随机的数据，并监控程序在这些输入数据下是否会出现崩溃、内置断言失败、内存泄漏、安全漏洞等情况。

Go1.5 版本发布的同时，Dmitry Vyukov 发布了 Go 语言模糊测试工具 **go-fuzz**。

**go-fuzz 的工作流程**：

1. 生成随机数据；
2. 将上述数据作为输入传递给北侧程序；
3. 观察是否有崩溃记录（crash），如果发现崩溃记录，则说明找到了潜在的 bug。

go-fuzz 采用的是**代码覆盖率引导的 fuzzing 算法**（Coverage-guided fuzzing）.

go-fuzz 的核心是**对语料库的输入数据如何进行变化**。go-fuzz 内部使用两种对语料库的输入数据进行变化的方法：突变（mutation）和改写（versify）。

- 突变是一种低级方法，主要是对语料库的字节进行小修改。
- 改写是比较先进的高级方法，它会学习文本的结构，对输入进行简单分析，识别出输入预料数据中各个部分的类型，比如数字、字母数字、列表、引用等，然后针对不同部分运用突变策略。

Go1.18 在标准工具链中开始支持 [fuzzing](https://go.dev/doc/fuzz/)。

官方教学：[Tutorial: Getting started with fuzzing](https://go.dev/doc/tutorial/fuzz)

小结：模糊测试最适合那些**处理复杂输入数据**的程序，比如文件格式解析、网络协议解析、人机交互界面入口等。模糊测试是软件测试技术的一个重要分支，与单元测试等互为补充，相辅相成。

## 46 为被测对象建立性能基准

性能基准测试在 Go 语言中是“一等公民”。每个以 Benchmark 前缀开头的函数都会被当做一个独立的性能基准测试。

Go 的性能基准测试分类：

- 顺序执行的性能基准测试。默认情况下，每个性能基准测试函数的执行时间为 1 秒，如果执行一轮所消耗的时间不足 1 秒，那么 go test 会按就近的顺序增加 b.N 的值：1、2、3、5、10、20、30、50、100 等。如果当 b.N 较小时，基准测试执行可以很快完成，那么 go test 基准测试框架将跳过中间的一些值，选择较大的值。

  ```Go
  func BenchmarkXxx(b *testing.B) {
      for i := 0; i < b.N; i++ {
          ...
      }
  }
  ```

- 并行执行的性能基准测试。并行执行的基准测试主要用于为包含多 goroutine 同步设施（如互斥锁、读写锁、原子操作等）的被测代码建立性能基准。相比于顺序执行的基准测试，并行执行的基准测试更能真实反映出多 goroutine 情况下，被测代码在 goroutine 同步上的真实消耗。

  ```Go
  func BenchmarkXxx(b *testing.B) {
      b.RunParallel(func(pb *testing.PB) {
          for pb.Next() {
              ...
          }
      })
  }
  ```

性能基准比较工具：

- [benchcmp](https://github.com/golang/tools/tree/master/cmd/benchcmp)：对 test 结果做简单比较。
- [benchstat](https://github.com/golang/perf/tree/master/cmd/benchstat)：统计学层面，提高对性能基准数据比较的科学性。

使用 testing.B 提供的定时器操作方法排除额外干扰，让基准测试更精确，但不要在 RunParallel 中使用 ResetTimer、StartTimer 和 StopTimer，因为它们具有全局副作用。

## 47 使用 pprof 对程序进行性能剖析

通过性能基准测试判定程序是否存在性能瓶颈，如存在，可通过 Go 工具链中的 pprof 对程序性能进行剖析。

使用 pprof 对程序进行性能剖析的工作一般分为两个阶段：**数据采集**和**数据剖析**。

**采样数据类型**：

- **CPU 数据**：帮助识别出代码关键路径上消耗 CPU 最多的函数。一旦启用 CPU 数据采样，Go 运行时会每隔一段短暂的时间（10ms）就中断一次（由 SIGPROF 信号引发）并记录当前所有 goroutine 的函数栈信息（存入 cpu.prof）。
- **堆内存分配数据**：帮助我们了解 Go 程序的当前和历史内存使用情况。堆内存分配的采样频率可配置，默认每 1000 次堆内存分配会做一次采样（存入 mem.prof）。
- **锁竞争数据**：记录当前 Go 程序中互斥锁争用导致延迟的操作（mutex.prof）。如果你认为很大可能是互斥锁争用导致 CPU 利用率不高，那么你可以为 pprof 提供此类采样文件以供性能剖析阶段使用，该类型采样数据在默认情况下是不启用的。
- **阻塞时间数据**：记录 goroutine 在某共享资源（一般是由同步原语保护）上的阻塞时间（block.prof），包括从无缓冲 channel 收发数据、阻塞在一个已经被其他 goroutine 锁住的互斥锁、向一个满了的 channel 发送数据或从一个空的 channel 接收数据等，该类型采样数据在默认情况下也是不启用的。

采样不是免费的，因此**一次采样尽量仅采集一种类型的数据**，不要同时采样多种类型的数据，避免相互干扰采样结果。

**性能数据采集的方式**：

- 通过性能基准测试进行数据采集。

- 独立程序的性能数据采集：通过标准库 runtime/pprof 和 runtime 包提供的低级 API 对独立程序进行性能数据采集；通过 net/http/pprof 包提供的高级 API，适合内置了 HTTP 服务的独立程序，将直接利用已有的 HTTP 服务对外提供用于性能数据采集的服务端点；如果是非 HTTP 服务程序，则在导入包的同时还需单独启动一个用于性能数据采集的 goroutine。

  ```Go
  ...
  fun main() {
      go func() {
          fmt.Println(http.ListenAndServe("localhost:8080", nil))
      }()
      ...
  }
  ```

**性能数据的剖析**：

- 命令行交互式：`go tool pprof xxx.prof`。常用命令：topN、list、png……
- Web 图形化：`go tool pprof -http=:9090 xxx.prof`。Graph 函数调用图、TOP 视图、Souce 视图、Flame Graph 火焰图等。

在不明确瓶颈原因的情况下，应优先对 CPU 类型和堆内存分配类型性能采样数据进行剖析。

## 48 使用 expvar 输出度量数据，辅助定位性能瓶颈点

通过独立程序进行性能数据采样时，往往很难快速捕捉到真正的瓶颈点，尤其是对于那些内部结构复杂、业务逻辑过多、内部有较多并发的 Go 程序。在对这样的程序进行性能采样时，真正的瓶颈点很可能被其他数据遮盖。

Go 标准库中的 expvar 包提供了一种输出应用内部状态信息的**标准化方案**。这个方案标准化了以下三方面内容：

- 数据输出接口形式；
- 输出数据的编码形式；
- 用户自定义性能指标的方法。

Go 应用如果需要输出自身状态数据，需要通过`import _ "expvar"`导入 expvar，expvar 包在自己的 init 函数中向 http 的默认请求“路由器”DefaultServeMux 注册一个服务端点 /debug/vars。

## 参考

《Go 语言精进之路：从新手到高手的编程思想、方法和技巧》——白明