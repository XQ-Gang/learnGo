# 标准库、反射与cgo

## 50 理解 Go TCP Socket 网络编程模型

### TCP Socket 网络编程模型

- **阻塞 I/O 模型**：在用户空间应用线程向操作系统内核发起 I/O 请求后（一般为操作系统提供的 I/O 系统调用），内核将尝试执行该 I/O 操作，并等所有数据就绪后，将数据从内核空间复制到用户空间，最后系统调用从内核空间返回。在这期间，用户空间应用线程将阻塞在该 I/O 系统调用上，无法进行后续处理，只能等待。
- **非阻塞 I/O 模型**：在用户空间线程向操作系统内核发起 I/O 请求后，内核会执行该 I/O 操作。如果此刻数据尚未就绪，就会立即将“未就绪”的状态以错误码形式返回给此次 I/O 系统调用的发起者。而后者则根据系统调用的返回状态决定下一步如何做。位于用户空间的 I/O 请求发起者通常会通过轮询的方式一次次发起 I/O 请求，直到读到所需的数据。
- **I/O 多路复用模型**：应用线程首先将需要进行 I/O 操作的 Socket 都添加到多路复用函数中，接着阻塞，等待系统调用返回。当内核发现有数据到达时，对应的 Socket 具备通信条件，函数返回。然后用户线程针对该 Socket 再次发起网络 I/O 请求。
- **异步 I/O 模型**：用户应用线程发起异步 I/O 调用后，内核将启动等待数据的操作并马上返回。之后，用户应用线程可以继续执行其他操作，既无需阻塞，也无须轮询并再次发起 I/O 调用。在内核空间数据就绪并被从内核空间复制到用户空间后，内核会主动生成信号以驱动执行用户线程在异步 I/O 调用时注册的信号处理函数，或主动执行用户线程注册的回调函数，让用户线程完成对数据的处理。

### TCP 连接的建立

对于客户端而言，建立连接时可能会遇到几种情形：

1. 网络不可达或对方服务未启动
2. 对方服务的 listen backlog 队列满了
3. 若网络延迟较大，Dial 将阻塞并超时

### Socket 读写

Go 运行时隐藏了 I/O 多路复用的复杂性，语言使用者只需采用**goroutine+阻塞I/O模型**即可满足大部分场景需求。

Dial 连接成功后会返回一个 net.Conn 接口类型的变量值，这个接口变量的底层类型为一个 *TCPConn:

```Go
// $GOROOT/src/net/tcpsock_posix.go
type TCPConn struct {
    conn
}
```

conn.Read 的行为特点：

- Socket 中无数据：goroutine 挂起
- Socket 中有部分数据：成功读出
- Socket 中有足够多的数据：分批读出
- Socket 关闭：直接返回 EOF
- 读操作超时
- 成功写
- 写阻塞
- 写入部分数据
- 写入超时
- goroutine 安全的并发读写

## 51 使用 net/http 包实现安全通信

### HTTPS：在安全传输层上运行的 HTTP 协议

HTTPS 协议就是用来解决传统 HTTP 协议明文传输不安全的问题的。

采用 HTTPS 协议后，新网络协议栈在应用层和传输层之间新增了一个**安全传输层**。安全传输层通常采用 SSL（Secure Socket Layer）或 TLS（Transport Layer Security）协议实现（Go 标准库支持 TLS1.3 版本协议）。这一层负责 HTTP 协议传输的内容加密、通信双方身份验证等。

### HTTPS 安全传输层的工作机制

安全传输层建立连接的过程也被称为“握手阶段”：

1. ClientHello（客户端->服务端）：客户端向服务端发出建立安全层传输连接，构建加密通信通道的请求。在这个请求中，客户端会向服务端提供本地最新的 TLS 版本、支持的加密算法组合的集合以及随机数等。

2. ServerHello & Server certificate & ServerKeyExchange（服务端->客户端）：

   1. 第一步，服务端收到客户端发过来的 ClientHello 请求后，用客户端发来的信息与自己本地支持的 TLS 版本、加密算法组合的集合做比较，选出一个 TLS 版本合一个合适的加密算法组合，然后生成一个随机数，一起打包到 ServerHello 中返回给客户端。
   2. 第二步，服务端会将自己的**服务端公钥证书**发送给客户端，这个服务端公钥证书身兼两大职责：客户端对服务端身份的验证以及后续双方会话密钥的协商和生成。如果服务端要验证客户端身份（可选的），那么这里服务端还会发现一个 CertificateRequest 的请求给客户端，要求对客户端的公钥证书进行验证。
   3. 第三步，发送开启双方会话秘钥协商的请求。相比非对称加密算法， 对称加密算法的性能要高出几个数量级，因此 HTTPS 在开始真正传输应用层的用户数据之前，选择了在非对称加密算法的帮助下协商一个基于对称加密算法的密钥。在密钥协商环节，通常会使用到 Diffie-Hellman（DH）密钥交换算法，这是一种密钥协商的协议，支持通信双方在不安全的通道上生成对称加密算法所需的共享密钥。因此，在这个步骤的请求中，服务端会向客户端发送密钥交换算法的相关参数信息。
   4. 最后，服务端以 Server Finished 作为该轮通信的结束标志。

3. ClientKeyExchange & ClientChangeCipher & Finished（客户端->服务端）：

   - 客户端在收到服务器的公钥证书后会对服务端的身份进行验证。如果验证失败，则此次安全传输层连接建立就会以失败告终，如果验证通过，那么客户端将从认证书中提取出服务端的公钥，用于加密后续协商密钥时发送给服务端的信息。

   - 如果服务端要求对客户端进行身份验证，那么客户端还需通过 ClientCertificate 将自己的公钥证书发送给服务端进行验证。

   - 收到服务端对称加密共享密钥协商的请求后，客户端根据之前的随机数、确定的加密算法组合以及服务端发来的参数计算出最终的会话密钥，然后将服务端单独计算出会话密钥所需的信息用服务端的公钥加密后以 ClientKeyExchange 请求发送给服务端。
   - 随后客户端用 ClientChangeCipher 通知服务端从现在开始发送的消息都是加密过的。
   - 最后，伴随着 ClientChangeCipher 消息，总会有一个 Finished 消息来验证双方的对称加密算法共享密钥协商是否成功。其验证的方法就是通过协商好的新共享密钥和对称加密算法对一段特定内容进行加密，并以服务端是否能够正确解密该请求报文作为密钥协商成功与否的判定标准。而被加密的这段特定内容包含的是连接至今的全部报文内容。Finished 报文作为该轮通信的结束标志，也是客户端发出的第一条使用协商密钥加密的信息。

4. ServerChangeCipher & Finished（服务端->客户端）：服务端收到客户端发过来的 ClientKeyExchange 中的参数后，也将单独计算出会话密钥。之后和客户端一样，服务端用 ServerChangeCipher 通知客户端从现在开始发送的消息都是加密过的。 最后，服务端用一个 Finished 信息跟在 ServerChangeCipher 后面，既用于标识该轮握手结束，也用于验证对方计算出来的共享密钥是否有效。这也是服务端发出的第一条使用协商密钥加密的信息。

### 非对称加密和公钥证书

**对称加密**指的是通信双方使用一个**共享密钥**，该密钥既用于传输数据的加密，也用于数据的解密。而**非对称加密**指通信的每一方都有两个密钥，一个公钥，一个私钥，通信的发送方使用对方的公钥对数据进行加密，数据接收方使用自己的私钥对数据进行解密。

对称加密性能好，但密钥的保存、管理、分发存在较大的风险；而非对称加密就是为了解决对称加密的密钥分发安全隐患而设计的。不过，非对称加密的性能相较于对称加密要差很多，这也是实际应用中会将两种加密方式结合使用的原因。

**如何保证 HTTPS 服务端发送给客户端的公钥信息没有被篡改呢**？在 HTTPS 建立连接的过程中并非直接传输公钥信息，而是使用携带公钥信息的**数字证书**来保证公钥信息的正确性和完整性。

**数字证书**，用于唯一标识网络上的一个域名地址或一台服务器主机。一般来说，数字证书是从受信的权威证书授权机构（CA）买来的，当然也有免费的。一般浏览器或操作系统在出厂时就内置了诸多知名 CA 的公钥数字证书，这些 CA 的公钥证书可以用于验证这些 CA 机构为网站颁发的公钥证书。对于这些内置 CA 公钥证书无法识别的证书，浏览器就会报错。

**CA 的公钥证书是如何校验服务端公钥证书的有效性的呢**？公钥证书的申请与校验过程：

1. 如果某个互联网服务站点要用 HTTPS 访问，那么它就需要向 CA 提交数字证书申请请求。这个请求以证书签名请求（Certificate Signing Request, CSR）文件的形式提供。
2. CA 收到客户的证书申请后，会按照标准数字证书规范生成该申请人的数字公钥证书。CA 的核心就是一个**私钥**以及由该私钥自签名的 **CA 公钥证书**（内置到操作系统和浏览器中分发）。公钥证书主要包含三部分：
   - 服务端公钥（server.pub）
   - 证书相关属性信息，如域名、有效期等
   - 证书颁发机构的签名信息
3. 公钥证书中的签名信息就是使用 ca.key 对证书中公钥信息与证书属性信息的摘要信息进行加密而得来的。当客户端使用 ca.crt 对服务端发来的公钥证书进行校验时，客户端会直接使用 ca.crt 中的公钥对公钥证书中的签名信息进行解密。然后比较解密得到的结果与使用相同摘要算法对证书中公钥信息与证书属性信息进行摘要计算后的结果，如果一致，则说明证书校验通过；否则，证书校验失败。一旦签名校验通过，我们因为信任这个 CA（的公钥证书），所以信任这个服务端证书。

因此，通过对证书签名信息的校验可以保证证书内容未被中途篡改，同时也确定了证书归属。

**数字证书**就是使用 CA 私钥对证书申请者的公钥和证书相关信息进行签名后的满足标准证书格式的信息。

## 参考

《Go 语言精进之路：从新手到高手的编程思想、方法和技巧》——白明