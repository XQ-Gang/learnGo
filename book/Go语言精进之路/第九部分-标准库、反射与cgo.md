# 标准库、反射与cgo

## 50 理解 Go TCP Socket 网络编程模型

### TCP Socket 网络编程模型

- **阻塞 I/O 模型**：在用户空间应用线程向操作系统内核发起 I/O 请求后（一般为操作系统提供的 I/O 系统调用），内核将尝试执行该 I/O 操作，并等所有数据就绪后，将数据从内核空间复制到用户空间，最后系统调用从内核空间返回。在这期间，用户空间应用线程将阻塞在该 I/O 系统调用上，无法进行后续处理，只能等待。
- **非阻塞 I/O 模型**：在用户空间线程向操作系统内核发起 I/O 请求后，内核会执行该 I/O 操作。如果此刻数据尚未就绪，就会立即将“未就绪”的状态以错误码形式返回给此次 I/O 系统调用的发起者。而后者则根据系统调用的返回状态决定下一步如何做。位于用户空间的 I/O 请求发起者通常会通过轮询的方式一次次发起 I/O 请求，直到读到所需的数据。
- **I/O 多路复用模型**：应用线程首先将需要进行 I/O 操作的 Socket 都添加到多路复用函数中，接着阻塞，等待系统调用返回。当内核发现有数据到达时，对应的 Socket 具备通信条件，函数返回。然后用户线程针对该 Socket 再次发起网络 I/O 请求。
- **异步 I/O 模型**：用户应用线程发起异步 I/O 调用后，内核将启动等待数据的操作并马上返回。之后，用户应用线程可以继续执行其他操作，既无需阻塞，也无须轮询并再次发起 I/O 调用。在内核空间数据就绪并被从内核空间复制到用户空间后，内核会主动生成信号以驱动执行用户线程在异步 I/O 调用时注册的信号处理函数，或主动执行用户线程注册的回调函数，让用户线程完成对数据的处理。

### TCP 连接的建立

对于客户端而言，建立连接时可能会遇到几种情形：

1. 网络不可达或对方服务未启动
2. 对方服务的 listen backlog 队列满了
3. 若网络延迟较大，Dial 将阻塞并超时

### Socket 读写

Go 运行时隐藏了 I/O 多路复用的复杂性，语言使用者只需采用**goroutine+阻塞I/O模型**即可满足大部分场景需求。

Dial 连接成功后会返回一个 net.Conn 接口类型的变量值，这个接口变量的底层类型为一个 *TCPConn:

```Go
// $GOROOT/src/net/tcpsock_posix.go
type TCPConn struct {
    conn
}
```

conn.Read 的行为特点：

- Socket 中无数据：goroutine 挂起
- Socket 中有部分数据：成功读出
- Socket 中有足够多的数据：分批读出
- Socket 关闭：直接返回 EOF
- 读操作超时
- 成功写
- 写阻塞
- 写入部分数据
- 写入超时
- goroutine 安全的并发读写

## 51 使用 net/http 包实现安全通信

### HTTPS：在安全传输层上运行的 HTTP 协议

HTTPS 协议就是用来解决传统 HTTP 协议明文传输不安全的问题的。

采用 HTTPS 协议后，新网络协议栈在应用层和传输层之间新增了一个**安全传输层**。安全传输层通常采用 SSL（Secure Socket Layer）或 TLS（Transport Layer Security）协议实现（Go 标准库支持 TLS1.3 版本协议）。这一层负责 HTTP 协议传输的内容加密、通信双方身份验证等。

### HTTPS 安全传输层的工作机制

安全传输层建立连接的过程也被称为“握手阶段”：

1. ClientHello（客户端->服务端）：客户端向服务端发出建立安全层传输连接，构建加密通信通道的请求。在这个请求中，客户端会向服务端提供本地最新的 TLS 版本、支持的加密算法组合的集合以及随机数等。

2. ServerHello & Server certificate & ServerKeyExchange（服务端->客户端）：

   1. 第一步，服务端收到客户端发过来的 ClientHello 请求后，用客户端发来的信息与自己本地支持的 TLS 版本、加密算法组合的集合做比较，选出一个 TLS 版本合一个合适的加密算法组合，然后生成一个随机数，一起打包到 ServerHello 中返回给客户端。
   2. 第二步，服务端会将自己的**服务端公钥证书**发送给客户端，这个服务端公钥证书身兼两大职责：客户端对服务端身份的验证以及后续双方会话密钥的协商和生成。如果服务端要验证客户端身份（可选的），那么这里服务端还会发现一个 CertificateRequest 的请求给客户端，要求对客户端的公钥证书进行验证。
   3. 第三步，发送开启双方会话秘钥协商的请求。相比非对称加密算法， 对称加密算法的性能要高出几个数量级，因此 HTTPS 在开始真正传输应用层的用户数据之前，选择了在非对称加密算法的帮助下协商一个基于对称加密算法的密钥。在密钥协商环节，通常会使用到 Diffie-Hellman（DH）密钥交换算法，这是一种密钥协商的协议，支持通信双方在不安全的通道上生成对称加密算法所需的共享密钥。因此，在这个步骤的请求中，服务端会向客户端发送密钥交换算法的相关参数信息。
   4. 最后，服务端以 Server Finished 作为该轮通信的结束标志。

3. ClientKeyExchange & ClientChangeCipher & Finished（客户端->服务端）：

   - 客户端在收到服务器的公钥证书后会对服务端的身份进行验证。如果验证失败，则此次安全传输层连接建立就会以失败告终，如果验证通过，那么客户端将从认证书中提取出服务端的公钥，用于加密后续协商密钥时发送给服务端的信息。

   - 如果服务端要求对客户端进行身份验证，那么客户端还需通过 ClientCertificate 将自己的公钥证书发送给服务端进行验证。

   - 收到服务端对称加密共享密钥协商的请求后，客户端根据之前的随机数、确定的加密算法组合以及服务端发来的参数计算出最终的会话密钥，然后将服务端单独计算出会话密钥所需的信息用服务端的公钥加密后以 ClientKeyExchange 请求发送给服务端。
   - 随后客户端用 ClientChangeCipher 通知服务端从现在开始发送的消息都是加密过的。
   - 最后，伴随着 ClientChangeCipher 消息，总会有一个 Finished 消息来验证双方的对称加密算法共享密钥协商是否成功。其验证的方法就是通过协商好的新共享密钥和对称加密算法对一段特定内容进行加密，并以服务端是否能够正确解密该请求报文作为密钥协商成功与否的判定标准。而被加密的这段特定内容包含的是连接至今的全部报文内容。Finished 报文作为该轮通信的结束标志，也是客户端发出的第一条使用协商密钥加密的信息。

4. ServerChangeCipher & Finished（服务端->客户端）：服务端收到客户端发过来的 ClientKeyExchange 中的参数后，也将单独计算出会话密钥。之后和客户端一样，服务端用 ServerChangeCipher 通知客户端从现在开始发送的消息都是加密过的。 最后，服务端用一个 Finished 信息跟在 ServerChangeCipher 后面，既用于标识该轮握手结束，也用于验证对方计算出来的共享密钥是否有效。这也是服务端发出的第一条使用协商密钥加密的信息。

### 非对称加密和公钥证书

**对称加密**指的是通信双方使用一个**共享密钥**，该密钥既用于传输数据的加密，也用于数据的解密。而**非对称加密**指通信的每一方都有两个密钥，一个公钥，一个私钥，通信的发送方使用对方的公钥对数据进行加密，数据接收方使用自己的私钥对数据进行解密。

对称加密性能好，但密钥的保存、管理、分发存在较大的风险；而非对称加密就是为了解决对称加密的密钥分发安全隐患而设计的。不过，非对称加密的性能相较于对称加密要差很多，这也是实际应用中会将两种加密方式结合使用的原因。

**如何保证 HTTPS 服务端发送给客户端的公钥信息没有被篡改呢**？在 HTTPS 建立连接的过程中并非直接传输公钥信息，而是使用携带公钥信息的**数字证书**来保证公钥信息的正确性和完整性。

**数字证书**，用于唯一标识网络上的一个域名地址或一台服务器主机。一般来说，数字证书是从受信的权威证书授权机构（CA）买来的，当然也有免费的。一般浏览器或操作系统在出厂时就内置了诸多知名 CA 的公钥数字证书，这些 CA 的公钥证书可以用于验证这些 CA 机构为网站颁发的公钥证书。对于这些内置 CA 公钥证书无法识别的证书，浏览器就会报错。

**CA 的公钥证书是如何校验服务端公钥证书的有效性的呢**？公钥证书的申请与校验过程：

1. 如果某个互联网服务站点要用 HTTPS 访问，那么它就需要向 CA 提交数字证书申请请求。这个请求以证书签名请求（Certificate Signing Request, CSR）文件的形式提供。
2. CA 收到客户的证书申请后，会按照标准数字证书规范生成该申请人的数字公钥证书。CA 的核心就是一个**私钥**以及由该私钥自签名的 **CA 公钥证书**（内置到操作系统和浏览器中分发）。公钥证书主要包含三部分：
   - 服务端公钥（server.pub）
   - 证书相关属性信息，如域名、有效期等
   - 证书颁发机构的签名信息
3. 公钥证书中的签名信息就是使用 ca.key 对证书中公钥信息与证书属性信息的摘要信息进行加密而得来的。当客户端使用 ca.crt 对服务端发来的公钥证书进行校验时，客户端会直接使用 ca.crt 中的公钥对公钥证书中的签名信息进行解密。然后比较解密得到的结果与使用相同摘要算法对证书中公钥信息与证书属性信息进行摘要计算后的结果，如果一致，则说明证书校验通过；否则，证书校验失败。一旦签名校验通过，我们因为信任这个 CA（的公钥证书），所以信任这个服务端证书。

因此，通过对证书签名信息的校验可以保证证书内容未被中途篡改，同时也确定了证书归属。

**数字证书**就是使用 CA 私钥对证书申请者的公钥和证书相关信息进行签名后的满足标准证书格式的信息。

## 52 掌握字符集的原理和字符编码方案间的转换

Go 语言源码默认使用 Unicode 字符集，并采用 UTF-8 编码方案，Go 还提供了 rune 原生类型来表示 Unicode 字符。

计算机字符集中的每个字符都有两个属性：**码点（code point）和表示这个码点的内存编码**（位模式，表示这个字符码点的二进制比特串）。

乱码的主要原因是**字符集不兼容**，即一个内存编码表示在不同的字符集中对应的是不同的字符。

**Unicode** (Universal Multiple-Octet Coded Character Set) 中文含义是“**通用多字节编码字符集**”。Unicode 码点的范围从 0x000000 到 0x10FFFF，一共可以容纳 110 多万个字符。Unicode 的前 128 个码点与 ASCII 字符码点是一一对应的。

**UTF-8** 使用变长度字节对 Unicode 字符（的码点）进行编码。编码采用的字节数量与 Unicode 字符在码点表中的序号有关：**表示序号（码点）小的字符使用的字节就少，表示序号（码点）大的字符使用的字节就多**。UTF-8 编码使用的字节从 1 到 4 不等。前 128 个与 ASCII 字符重合的码点（U+0000~U+007F）使用 1 字节表示；带变音符号的拉丁文、希腊文、西里尔字母、阿拉伯文等使用 2 字节来表示；而汉字使用 **3 字节**表示；其他极少使用的语言的字符则使用 4 字节表示。

在 Go 中，**每个 rune 对应一个 Unicode 字符的码点**。

使用 Go 标准库及其依赖库 golang.org/x/text 下的包，可以实现 UTF-8 与其他字符集编码的相互转换，还可以实现任意字符集编码之间的相互转换。我们使用一个惯用的 **transform.Reader 链**结构完成数据在不同编码的转换。

## 53 掌握使用 time 包的正确方式

**time.Time 的结构**：

```Go
type Time struct {
   wall uint64 // 挂钟时间，用于告知当前时间，可能出现“时间倒流”，连续两次采集之差不一定都正值
   ext  int64  // 单调时间（纳秒），表示程序进程启动之后流逝的时间，两次采集之差不可能为负数
   loc *Location // 指向时区信息的指针
}
```

wall 字段由 hasMonotonic（1bit）、秒数（33bit，距离 1885 年 1 月 1 日的秒数）、纳秒数（30bit）三部分组成。hasMonotonic=1 时，ext 字段表示单调流逝时间；hasMonotonic=0 时，ext 字段整个用于表示挂钟时间的整秒部分（距离公元元年 1 月 1 日的秒数）。通过 time.Parse、time.Date、time.Unix 构建的 time.Time 结构体其中的 hasMonotonic 均为 0.

**时间的基础操作**：

- 获取当前时间：time.Now
- 获取特定时区的当前时间：
  - 设置 TZ 环境变量：$TZ=XXX
  - 显式加载时区信息：time.LoadLocation
- 时间的比较和运算：Equal 方法（如果两个 Time 均带有单调时间，直接比较两者单调时间是否相等；否则，分别比较两个时间的整秒部分和非整秒部分，如果两个部分分别相等，那么两个时间相同，否则不同）；Before 方法、After 方法用于判断两个即时时间的先后关系；
- 时间的运算：Sub 方法提供差值计算返回 time.Duration 类型（纳秒值，如果两个 Time 都含有单调时间，直接返回 ext 字段的差；否则分别算出整秒部分和非整秒部分的差，然后加和后返回）；Since方法、Until 方法均是基于 Sub 方法实现的；

**时间的格式化输出**：Go 语言采用直观的**参考时间** `01/02 03:04:05PM '06 -0700` 替代 strftime 的各种标准占位符。

**time 包提供了两类定时器**：一次性定时器 Timer 和重复定时器 Ticker。

time.Timer 的结构：

```Go
type Timer struct {
   C <-chan Time  // 用户层用户接收定时器触发事件的 channel
   r runtimeTimer // 一个与 runtime.timer 对应且保持一致的结构
}
```

**定时器的使用**：

- Timer 的创建：NewTimer；AfterFunc；After；

- Timer 的资源释放：在定时器被从最小堆移出并触发事件后，其占用的内存资源、channel 等都会在后续被垃圾收集器回收。因此尽量减少在使用 Timer 时对最小堆管理和垃圾回收的压力，即及时调用定时器的 Stop 方法从最小堆删除定时器或重用（Reset 处于活跃状态的定时器）。

- 停止 Timer：Stop 方法

- 重用 Timer：Reset 方法（Go 官方文档建议只对两种定时器调用 Reset 方法：① 已经停止了的定时器；② 已经触发过且 Timer.C 中的数据已经被读空），Go 官方文档给出了推荐的使用模式：

  ```Go
  if !t.Stop() {
      <-t.C
  }
  t.Reset(d)
  
  // 有时，可以使用 select 的 default 分支防止阻塞
  if !t.Stop() {
      select {
          case <-timer.C:
          default:
      }
  }
  t.Reset(d)
  ```

- [重用 Timer 时存在的竞态条件](https://github.com/golang/go/issues/11513)：尚无理想解决方案

## 54 不要忽略对系统信号的处理

**系统信号**（signal）是一种**软件中断**，它提供了一种异步的事件处理机制，用于操作系统内核或其他应用进程通知某一应用进程发生了某种事件。通过系统信号是实现**优雅退出**的一种常见手段。

应用程序收到系统信号后，一般有三种处理方式：

- 执行系统默认处理动作
- 忽略信号
- 捕捉信号并执行自定义处理动作

服务端程序一般都是以**守护进程**的形式运行在后台，我们一般都是通过系统信号通知这些守护程序执行退出操作。如果以系统默认方式处理退出通知信号，那么守护进程直接被杀死，没有机会执行清理和收尾工作。因此，应采**用捕捉退出信号的方式**执行自定义的收尾处理函数。

**os/signal** 包最主要的函数：`func Notify(c chan<- os.Signal, sig ...os.Signal)`，用来设置捕捉那些应用关注的系统信号，并在 Go 运行时层与 Go 用户层之间用一个 channel 相连。Go 运行时捕捉到应用关注的信号后，会将信号写入 channel，这些监听该 channel 的用户层代码便可接收该信号通知。

Go 信号分为两大类：

- **同步信号**：由程序执行错误引发的信号，包括 SIGBUS（总线错误/硬件异常）、SIGFPE（算数异常）、SIGSEGV（段错误/无效内存引用）。应用极大可能出现了严重 bug，Go 运行时直接将信号转换成一个运行时 panic 并抛出。如果用户层没有专门的 panic 恢复代码，那么 Go 应用将默认异常退出。
- **异步信号**：不是由程序执行错误引起的，而是由其他程序或操作系统内核发出的。异步信号的默认处理行为因信号而异。对于用户层通过 Notify 函数捕获的信号，Go 运行时则通过 channel 将信号发给用户层。

Notify 无法捕捉终止程序信号 SIGKILL 和挂起程序信号 SIGSTOP（操作系统机制决定的），也无法捕捉同步信息（Go 运行时决定的），只有捕捉异步信号才是有意义的。

实现http服务优雅退出的典型方案：

- 首先，我们通过`Notify`捕获`SIGINT`、`SIGTERM`、`SIGQUIT`和`SIGHUP`这四个系统信号，这样当这四个信号中的任何一个触发时，我们的http服务都有机会在退出前做一些清理工作；
- 我们使用`http`包提供的`Shutdown`来实现http服务内部的退出清理工作：包括立即关闭所有listener、关闭所有空闲的连接、等待处于活动状态的连接处理完毕(变成空闲连接)等；
- `http.Server`还提供了`RegisterOnShutdown`方法以允许开发者注册`shutdown`时的回调函数。这是个在服务关闭前清理其他资源、做收尾工作的**好场所**；注册的函数将在一个单独的goroutine中执行，但`Shutdown`不会等待这些回调函数执行完毕。

## 55 使用 crypto 下的密码学包构建安全应用

标准库 crypto 实现的密码学包大致分为：

- 对称密码（分组密码）：解决数据机密性的问题

  - 一次仅能处理固定长度（分组长度）数据块的算法
  - 最后一组可能需要填充
  - 如 DES、AES 加密算法
  - 迭代的方法称为分组密码算法的模式
  - 对称密码（加解密采用同一把密钥）是典型的分组密码
  - **AES** 是对称密码算法的首选

- 公钥密码：解决密钥分发的问题

  - 每个通信方都会生成两把密钥：私有密钥、公共密钥

  - **RSA** 是世界上使用最广泛的公钥密码算法

  - 公钥 (E, N)，私钥 (D, N) 

    加密：RSA 密文就是对代表明文的数字的 E 次方求 mod N 的结果

    解密：明文就是对代表 RSA 密文的数字的 D 次方求 mod N 的结果

  - RSA 算法对待处理的数据长度是有要求的

- 单向散列函数：解决消息完整性检查问题

  - 一个接受**不定长输入**但产生**定长输出**（**摘要**digest、**指纹**fingerprint）的函数
  - 输入可以是任何长度的比特序列代表的事物
  - 无法通过散列值反算出输入的消息原文
  - 标准库提供 MD5、SHA-1、SHA-256、SHA-384、SHA-512 等的实现
  - **SHA-2** 标准是目前应用最为广泛且强抗碰撞性尚未被攻破的单向散列函数标准，SHA-256 是此标准中使用最多的单向散列函数
  - 虽然能辨别出数据是否被篡改，但却无法辨别出数据是不是伪装的，还需要消息认证来校验消息的来源是不是我们所期望的

- 消息认证码：可以识别伪装者

  - 一种不仅能确认数据完整性，还能保证消息来自期望来源的密码技术
  - 以通信双方共享密钥为前提
  - 对于任意长度的消息，都可以计算出一个固定长度的消息认证码数据（**MAC 值**）
  - 对数据进行对称加密且携带 MAC 值的方式被称为“认证加密”（AEAD）
  - 虽然解决了消息发送者的身份认证问题，但由于采用消息认证码的通信双方**共享密钥**，对于一条通过了 MAC 验证的消息，通信双方依旧无法向第三方证明这条消息就是对方发送的，同时任何一方也都没有办法防止否认该条消息是自己发送的。也就是说单凭消息认证码无法**防止否认**。

- 数字签名：解决消息究竟是谁所发的问题，防止否认

  - 用私钥对消息原文或摘要进行加密，用公钥对私钥加密的消息进行解密
  - 一旦使用某公钥成功解密了某密文，那么就可以证明这段密文是用与该公钥配对的私钥加密得到的
  - 带有数字签名的消息彻底解决了向第三方证明这条消息究竟是谁发送的问题；同时凭借签名，发送方再也无法否认
  - 实际生产应用中，我们通常对消息的摘要进行签名
  - RSA-PSS 算法通过采用对消息摘要进行签名，并在计算散列值时对消息加盐的方式来提高安全性
  - 大前提是**公钥属于真正的发送者**，这就涉及公钥分发问题
  - 数字证书本质上就是将公钥当做消息，由一个可信的第三方证书签发授权组织（CA）使用私钥对其进行签名

- 随机数生成：密码学建构的基础

  - crypto/rand 提供了密码学级别的随机数生成器实现 rand.Reader

## 参考

《Go 语言精进之路：从新手到高手的编程思想、方法和技巧》——白明

