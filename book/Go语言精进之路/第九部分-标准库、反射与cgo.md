# 标准库、反射与cgo

## 50 理解 Go TCP Socket 网络编程模型

### TCP Socket 网络编程模型

- **阻塞 I/O 模型**：在用户空间应用线程向操作系统内核发起 I/O 请求后（一般为操作系统提供的 I/O 系统调用），内核将尝试执行该 I/O 操作，并等所有数据就绪后，将数据从内核空间复制到用户空间，最后系统调用从内核空间返回。在这期间，用户空间应用线程将阻塞在该 I/O 系统调用上，无法进行后续处理，只能等待。
- **非阻塞 I/O 模型**：在用户空间线程向操作系统内核发起 I/O 请求后，内核会执行该 I/O 操作。如果此刻数据尚未就绪，就会立即将“未就绪”的状态以错误码形式返回给此次 I/O 系统调用的发起者。而后者则根据系统调用的返回状态决定下一步如何做。位于用户空间的 I/O 请求发起者通常会通过轮询的方式一次次发起 I/O 请求，直到读到所需的数据。
- **I/O 多路复用模型**：应用线程首先将需要进行 I/O 操作的 Socket 都添加到多路复用函数中，接着阻塞，等待系统调用返回。当内核发现有数据到达时，对应的 Socket 具备通信条件，函数返回。然后用户线程针对该 Socket 再次发起网络 I/O 请求。
- **异步 I/O 模型**：用户应用线程发起异步 I/O 调用后，内核将启动等待数据的操作并马上返回。之后，用户应用线程可以继续执行其他操作，既无需阻塞，也无须轮询并再次发起 I/O 调用。在内核空间数据就绪并被从内核空间复制到用户空间后，内核会主动生成信号以驱动执行用户线程在异步 I/O 调用时注册的信号处理函数，或主动执行用户线程注册的回调函数，让用户线程完成对数据的处理。

### TCP 连接的建立

对于客户端而言，建立连接时可能会遇到几种情形：

1. 网络不可达或对方服务未启动
2. 对方服务的 listen backlog 队列满了
3. 若网络延迟较大，Dial 将阻塞并超时

### Socket 读写

Go 运行时隐藏了 I/O 多路复用的复杂性，语言使用者只需采用**goroutine+阻塞I/O模型**即可满足大部分场景需求。

Dial 连接成功后会返回一个 net.Conn 接口类型的变量值，这个接口变量的底层类型为一个 *TCPConn:

```Go
// $GOROOT/src/net/tcpsock_posix.go
type TCPConn struct {
    conn
}
```

conn.Read 的行为特点：

- Socket 中无数据：goroutine 挂起
- Socket 中有部分数据：成功读出
- Socket 中有足够多的数据：分批读出
- Socket 关闭：直接返回 EOF
- 读操作超时
- 成功写
- 写阻塞
- 写入部分数据
- 写入超时
- goroutine 安全的并发读写

## 参考

《Go 语言精进之路：从新手到高手的编程思想、方法和技巧》——白明