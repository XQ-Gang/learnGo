# 工具链与工程实践

## 61 使用 module 管理包依赖

Go module 的引入在 “去 GOPATH” 之路上更进了一步，它引入了一种新的依赖管理工作模式：**“module-aware mode”**。在该模式下，通常一个仓库的顶层目录下会放置一个 `go.mod` 文件，每个 `go.mod` 文件唯一定义了一个 module。Go1.16 开始，Go module-aware 模式成为默认模式。

**一个 module 就是由一组相关包组成的一个独立的版本单元**。在一个仓库中定义多个 module 的用法**严重不建议使用**。

[最小版本选择](https://research.swtch.com/vgo-mvs)（minimal version selection, mvs）：Go 团队相信 MVS 为 Go 程序实现持久的和可重复的构建提供了最佳的方案。最小版本选择算法用于选择 build 中使用的所有 modules 的版本。对于 build 中的每个 module，通过最小版本选择算法选择的版本始终是主 module 或其依赖项之一通过`require`指令显式列出的版本中语义最高的版本。简单来说就是：使用`require`中的最高版本。

go.sum 记录每个依赖库的版本和对应的内容的校验和 (一个哈希值)。每当增加一个依赖项时，如果 `go.sum` 中没有，则会将该依赖项的版本和内容校验和添加到 `go.sum` 中。go 命令会使用这些校验和与缓存在本地的依赖包副本元信息进行比对校验。`go.sum` 文件不应被用于理解依赖关系，它只是一个 “元信息数据库”。随着项目依赖的演化变更，`go.sum` 文件中会存储着一个 module 的多个版本信息，即使某个版本已经不再被当前 module 所依赖。

Go 命令行工具：

- 输出 build list：`go list -m -json all`
- 清楚 mod 缓存：`go clean -modcache`
- 清理 go.mod：`go mod tidy`
- 升降级依赖关系：`go get A@v0.0.0`

Go 环境变量：

- `GOPROXY`：配置公共 module 代理服务
- `GOSUMDB`：配置 Go 校验和数据库的服务地址（和公钥）
- `GOPRIVATE`：获取私有 module

## 62 构建最小 Go 程序容器镜像

Docker 是基于 Namespaces 和 Cgroups 技术之上实现的，Docker 的创新之处在于其基于 [Union File System](https://en.wikipedia.org/wiki/UnionFS) 技术定义了一套容器打包规范，真正将容器中的应用及其运行的所有依赖都封装到一种特定格式的文件中去，而这种文件就被称为**镜像**（即 image）。

镜像是容器的 “序列化” 标准，这一创新为容器的存储、重用和传输奠定了基础。采用 `Dockerfile` 方式构建成为镜像构建的标准方法，其可重复、可自动化、可维护以及分层精确控制等特点是采用传统采用 `docker commit` 命令提交的镜像所不能比拟的。

目标镜像的构建被分为了两个阶段：

1. 第一阶段：构建负责编译源码的构建者镜像；
2. 第二阶段：将第一阶段的输出作为输入，构建出最终的目标镜像。

Go 应用有着 (静态) 编译为单一可执行文件的 “先天特性”，这使得我们可以结合最新容器构建技术为其构建出极小的镜像，使其在云原生生态系统中能发挥出更大的优势，得以更为广泛的应用。

## 参考

《Go 语言精进之路：从新手到高手的编程思想、方法和技巧》——白明

