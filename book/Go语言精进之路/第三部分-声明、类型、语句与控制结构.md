# 声明、类型、语句与控制结构

## 8 使用一致的变量声明形式

Go 语言有两类变量：

- 包级变量：在 package 级别可见的变量，如果是导出变量，则该包级变量也可以被视为全局变量。
- 局部变量：函数或方法体内声明的变量，仅在函数或方法体内可见。

包级变量的声明形式：

- **声明并同时显式初始化**：`var variableName = InitExpression`。Go 编译器会自动根据右侧的 InitExpression 表达式求值的类型确定左侧所声明变量的类型，整型初始化默认为 int，浮点值初始化默认为 float64，如果不接受默认类型，而是要显示指定类型，推荐使用`var a = float32(3.14)`，不推荐使用`var a float32 = 3.14`。
- **声明但延迟初始化**：`var variableName variableType`。虽然没有显式初始化，但 Go 语言会让这些变量拥有初始的“**零值**”。如果是自定义的类型，保证其零值可用是非常必要的。
- **声明聚类**：将同一类的变量声明放在一个 var 块中，将不同类的声明放在不同的 var 块中；或者将延迟初始化的变量放在一个 var 块，而将声明并显式初始化的变量放在另一个 var 块中。
- **就近原则**：尽可能在靠近第一次使用变量的位置声明该变量。就近原则实际上是变量的**作用域最小化**的一种实现手段。

局部变量的声明形式：

- 对于**延迟初始化**的局部变量声明，采用带有 var 关键字的声明形式：`var b []byte`。
- 对于**声明且显式初始化**的局部变量，建议使用**短变量**声明形式：`a := 3.14`，对于不接受默认类型的变量：`a := float32(3.14)`。
- 尽量在**分支控制**时应用**短变量**声明形式：`for _, b := range *v`。体现出“**就近原则**”，让变量的作用域最小化。
- 对于良好的函数/方法设计讲究的是“**单一职责**”，因此每个函数/方法的规模都不大，很少需要应用 var 块来聚类声明局部变量。当然，如果遇到适合聚类的应用场景，也应该毫不犹豫地使用 var 块来声明多个局部变量。

## 9 使用无类型常量简化代码

Go 语言中的 const 整合了 C 语言中宏定义常量、const 只读变量和枚举变量三种形式，并消除了每种形式的不足，使得 Go 常量成为**类型安全**且**对编译器优化友好**的语法元素。Go 常量在声明时并不显式指定类型，也就是说使用的是**无类型常量**。

所有常量表达式的求值计算都可以在**编译期**而不是在**运行期**完成，这样既可以减少运行时的工作，也能方便编译器进行编译优化。当操作数是常量时，在编译时也能发现一些运行时的错误，例如整数除零、字符串索引越界等。

无类型常量是 Go 语言推荐的实践，它拥有和字面值一样的灵活特性，可以直接用于更多的表达式而不需要进行显示类型转换，从而简化了代码编写。此外，按照 [Go 官方语言规范](https://tip.golang.org/ref/spec#Constants) 的描述，数值型无类型常量可以提供比基础类型更高精度的算术运算，至少有 256bit 的运算精度。

## 10 使用 iota 实现枚举常量

Go 的 const 语法提供了“**隐式重复前一个非空表达式**”的机制。

```Go
const (
   a, b = 1, 11
   c, d // 1, 11
   e, f // 1, 11
)
```

iota 是 Go 语言的一个预定义标识符，它表示的是 const 声明块（包括单行声明）中每个常量所处位置在块中的偏移值（从零开始）。

```Go
const (
   _     = iota
   Blue  // 1
   Black // 2
   Red   // 3
   _
   Yellow = iota * 2 // 10
   Green             // 12
)
```

iota 让 Go 在枚举常量定义上表达力大增，主要体现在：

- 能够以更为灵活的形式为枚举常量赋初值。
- 不限于整型值，也可以定义浮点型的枚举常量。
- 使得维护枚举常量列表更容易。
- 使用有类型枚举常量保证类型安全。

## 11 尽量定义零值可用的类型

> 保持零值可用。——[Go 谚语](https://go-proverbs.github.io/)

Go 语言中的每个原生类型都有其默认值，这个默认值就是这个类型的零值。如下所示：

- 整型类型：0
- 浮点类型：0.0
- 布尔类型：false
- 字符串类型：""
- 指针、interface、切片、channel、map、function：nil

Go 的零值初始是**递归**的，即数组、结构体等类型的零值初始化就是对其组成元素逐一进行零值初始化。

Go 语言**零值可用**理念给内置类型、标准库的使用者带来很多便利。不过 Go 并非所有类型都是零值可用的，并且零值可用也有一定的限制。

```Go
// 零值可用的切片不能通过下标形式操作数据
var s []int
s[0] = 12         // 报错！
s = append(s, 12) // 正确

// map 没有提供零值可用支持
var m map[string]int
m["go"] = 1 // 报错！

m1 := make(map[string]int)
m1["go"] = 1 // 正确

// 尽量避免值复制
var mu sync.Mutex
mu1 := mu
foo(mu)

// 可以通过指针方式传递类似 Mutex 这样的类型
var mu sync.Mutex
foo(&mu)
```

## 12 使用复合字面值作为初值构造器

**复合字面值**（composite literal）由两部分组成：一部分是类型；另一部分是由大括号{}包裹的字面值。

**结构体复合字面值**：Go 推荐使用`field: value`的复合字面值形式对 struct 类型变量进行值构造，这种值构造方式可以降低结构体类型使用者与结构体类型设计者之间的耦合，因为一旦该结构体类型增加了一个新的字段，即使是未导出的，这种值构造方式也将导致编译失败，这也是 Go 语言的惯用法。结构体中的字段可以以**任意次序**出现，未显式出现在字面值的结构体中的字段将采用其对应类型的**零值**，但不允许将从其他包导入的结构体中的**未导出字段**作为复合字面值中的 field，这会导致编译错误。

**数组/切片复合字面值**：使用**下标**（index）作为`field: value`形式中的 field，从而实现数组/切片初始元素值的高级构造形式。主要应用于少数场合，比如非连续（**稀疏**）元素构造初值，让编译器根据最大元素下标值推导数组的大小。另外，在编写单元测试时，为了更显著地体现元素对应的下标值，可能会使用`index: value`形式来为数组/切片进行值构造。

```Go
numbers := [256]int{'a': 8, 'b': 7, 'c': 4, 'd': 3, 'e': 2, 'y': 1, 'x': 5}
// 注：'a' == 97
fnumbers := [...]float64{-1, 4: 2, 3, 7: 4, 9: 5} // [10]float64, [-1 0 0 0 2 3 0 4 0 5]
```

**map 复合字面值**：原生的`key: value`构造形式，当 key 和 value 的类型为复合类型时，我们可以省去 key 或 value 中的复合字面量中的类型（Go1.5）。

```Go
type Point struct {
   x float64
   y float64
}
m := map[string]*Point{
   "Persepolis": {29.9, 52.9},
   "Uluru":      {-25.4, 131.0},
   "Googleplex": {37.4, -122.1},
}
```

## 13 了解切片实现原理并高效使用

切片之于数组就像是文件描述符之于文件。切片是数组的“**描述符**”，之所以能在函数参数传递时避免较大性能损耗，是因为它是“描述符”的特性，切片这个描述符是固定大小的，无论底层的数组元素类型有多大，切片打开的窗口有多长。

下面是切片在 Go 运行时（runtime）层面的内部表示：

```Go
type slice struct {
   array unsafe.Pointer // 指向下层数组某元素的指针，该元素也是切片的初始元素
   len   int            // 切片的长度，即切片中当前元素的个数
   cap   int            // 切片的最大容量，cap >= len
}
```

如果没有在 make 中指定 cap 参数，那么 cap = len，即编译器建立的数组长度为 len。

我们可以通过语法 `u[low:high]` 创建对已存在数组进行操作的切片，称为**数组的切片化**（slicing）。如果一个数组有多个切片，无论通过哪个切片对数组进行的修改操作都会反映到其他切片中。

还可以语法 `s[low:high]` 基于已有切片创建新的切片，称为**切片的 reslicing**。新创建的切片与原切片同样是共享底层数组的，并且通过新切片对数组的修改也会反映到原切片中。切片可以提供比指针更为强大的功能，比如下标访问、边界溢出校验、动态扩容等，但不支持指针算术运算。

**动态扩容**：append 会根据切片的需要，在当前底层数组容量无法满足的情况下，动态分配新的数组，新数组长度会按一定算法扩展。新数组建立后，append 会把旧数组中的数据**复制**到新数组中，之后新数组便成为切片的底层数组，旧数组后续会被**垃圾回收**掉。

```Go
u := [...]int{0, 1, 2, 3, 4, 5, 6}
var s = u[4:5]
fmt.Println(len(s), cap(s), u) // 1 3 [0 1 2 3 4 5 6]
s = append(s, 7)
fmt.Println(len(s), cap(s), u) // 2 3 [0 1 2 3 4 7 6]
s = append(s, 8)
fmt.Println(len(s), cap(s), u) // 3 3 [0 1 2 3 4 7 8]

// 此时切片 s 与 数组 u 共享底层数组，同步改动
s[0] = 20
fmt.Println(len(s), cap(s), u) // 3 3 [0 1 2 3 20 7 8]

// 底层数组剩余空间不满足添加新元素，创建了新的底层数组（长度为原 2 倍）
s = append(s, 9)
fmt.Println(len(s), cap(s), u) // 4 6 [0 1 2 3 20 7 8]

// 此时与原数组 u 解除绑定，再修改切片 s 不会影响原数组 u
s[0] = 21
fmt.Println(len(s), cap(s), u) // 4 6 [0 1 2 3 20 7 8]

s = append(s, 10)
fmt.Println(len(s), cap(s), u) // 5 6 [0 1 2 3 20 7 8]
s = append(s, 11)
fmt.Println(len(s), cap(s), u) // 6 6 [0 1 2 3 20 7 8]

// 又创建了新的底层数组
s = append(s, 12)
fmt.Println(len(s), cap(s), u) // 7 12 [0 1 2 3 20 7 8]

// 查看切片
fmt.Println(s) // [21 7 8 9 10 11 12]
```

**尽量使用 cap 参数创建切片**：append 让切片类型部分满足了“零值可用”的理念，但从其原理能看到重新分配底层数组并复制元素的操作代价还是挺大的，尤其是当元素较多的情况下，如何减少或避免为过多内存分配和复制付出的代价？一种有效的方法是根据切片的使用场景对切片的容量规模进行**预估**，并在创建新切片时将预估出的切片容量数据以 cap 参数的形式传递给内置函数 make：`s := make([]T, len, cap)`，这样可以提升 append 的平均操作性能，减少或消除因动态扩容带来的性能损耗。

## 14 了解 map 实现原理并高效使用

### 什么是 map？

map 表示一组无序的键值对`key-value`，map 对 value 没有限制，但是对 key 的类型有严格要求：**key 的类型应该严格定义了作为 “==” 和 “!=” 两个操作符的操作数时的行为**。因此**函数**、**map**、**切片**不能作为 map 的 key 类型。

map 类型不支持“零值可用”，未显式赋初值的 map 类型变量的零值为 **nil**，对处于零值状态的 map 变量进行操作将会导致运行时 panic。创建 map 类型变量有两种方式：

- 使用复合字面值创建 map 类型变量。
- 使用 make 创建 map 类型变量。

和切片一样，map 也是引用类型，将 map 类型变量作为函数参数传入不会有很大的性能损耗，并且在函数内部对 map 变量的修改在函数外部也是可见的。

### 基本操作

- 查找：判断某个 key 是否存在与某个 map 中，可以使用**"comma ok"惯用法**来进行查找：

  ```Go
  _, ok := m["key"]
  if !ok {
     // "key" 不在 map 中
  }
  ```

- 取值：如果要读取 key 对应的 value 值：`v := m["key"]`，如果 key 不存在于 map 中，v 会被赋予一个“合法”值 0，这个值是 value 类型 int 的**零值**。在这样的情况下，我们无法判断这个 0 是"key"对应的值还是因为"key"不存在而返回的零值，为此我们还需要借助"comma ok"惯用法。

- 删除：`delete(m, "key")`，即使要删除的数据在 map 中不存在，delete 也不会导致 panic。
- 遍历：`for k, v := range m`，注意千万**不要依赖遍历 map 所得到的元素次序**，如果需要一个稳定的遍历次序，一个通用做法是使用另一种数据结构来按需要的次序保存 key，比如切片。

### map 底层实现

与语法层面 map 类型变量一一对应的是 runtime.hmap 类型的实例。hmap 是 map 类型的 header，可以理解为 map 类型的描述符，它存储了后续 map 类型操作所需的所有信息。

```Go
type hmap struct {
   count     int    // 当前 map 中元素个数，len 函数返回的就是 count 的值
   flags     uint8  // 当前 map 所处的状态标志：iterator、oldIterator、hashWriting、sameSizeGrow
   B         uint8  // bucket 数量的以 2 为底的对数，即 2^B = bucket数量
   noverflow uint16 // overflow bucket 的大约数量
   hash0     uint32 // 哈希函数的种子值

   buckets    unsafe.Pointer // 指向 bucket 数组的指针
   oldbuckets unsafe.Pointer // 在 map 扩容阶段指向前一个 bucket 数组的指针
   nevacuate  uintptr        // 在 map 扩容阶段充当扩容进度计数器，所有下标小于 nevacuate 的 bucket 都已经完成了数据排空和迁移操作

   extra *mapextra // 可选字段。如果有 overflow bucket 存在，且 key、value 都因不包含指针而被内联的情况下，该字段将存储所有指向 overflow bucket 的指针，保证 overflow bucket 是始终可用的（不被垃圾回收掉）
}
```

真正用来存键值对数据的是 **bucket**，每个 bucket 中存储的是 Hash 值低 bit 位数值相同的元素，默认的元素个数为 **BUCKETSIZE**(8)。当某个 bucket 的 8 个空槽(slot)都已填满且 map 尚未达到扩容条件时，运行时会建立 **overflow bucket**，并将该 overflow bucket 挂在上面 bucket 末尾的 overflow 指针上，这样两个 bucket 形成了一个链表结构，该结构的存在将持续到下一次 map 扩容。

每个 bucket 由三部分组成：tophash 区域、key 存储区域和 value 存储区域。

- **tophash 区域**：当向 map 插入一条数据或从 map 按 key 查询数据的时候，运行时会使用哈希函数对 key 做哈希运算并获得一个哈希值 **hashcode**。运行时将hashcode“一分为二”看待，其中低位区的值用于选定 bucket，高位区的值用于在某个 bucket 中确定 key 的位置。因此，每个 bucket 的 tophash 区域是用于快速定位 key 位置的，这样避免了逐个 key 进行比较这种代价较大的操作，尤其是当 key 是 size 较大的字符串类型时，这是一种以**空间换时间**的思路。

- **key 存储区域**：tophash 区域下面是一块连续的内存区域，存储的是该 bucket 承载的所有 key 数据。运行时在分配 bucket 时需要知道 key 的大小，当我们声明一个 map 类型变量时，Go 运行时就会为该变量对应的特定 map 类型生成一个 runtime.maptype 实例（如存在则复用）。

  ```Go
  type maptype struct {
     typ        _type
     key        *_type
     elem       *_type
     bucket     *_type // 表示 hash bucket 的内部类型
     keysize    uint8  // key 的大小
     elemsize   uint8  // elem 的大小
     bucketsize uint16 // bucket 的大小
     flags      uint32
  }
  ```

  该实例包含了 map 类型的所有元信息，编译器会将语法层面的 map 操作重写成运行时对应的**函数调用**，这些运行时函数有一个共同的特点：第一个参数都是 maptype 指针类型的参数。Go 运行时就是利用 maptype 参数中的信息确定 key 的类型和大小的，同时 maptype 的存在也让 Go 中所有 map 类型**共享一套**运行时 map 操作函数，而无需像 C++ 那样为每种 map 类型创建一套 map 操作函数，从而减少了对最终二进制文件空间的占用。

- **value 存储区域**：key 存储区域下方是另一块连续的内存区域，该区域存储的是 key 对应的 value，该区域的创建也得到了 maptype 中信息的帮助。Go 运行时采用了将 key 和 value **分开存储**而不是采用一个 kv 接着一个 kv 的 kv 紧邻方式存储，这带来的是算法上的复杂性，但却减少了因**内存对齐**带来的内存浪费。另外注意，如果 key 或 value 的数据长度大于一定数值，那么运行时不会在 bucket 中直接存储数据，而是会存储 key 或 value 数据的指针。目前 Go 运行时定义的最大 key 和 value 的长度是 128。

### map 扩容

Go 运行时的 map 实现中引入了一个 **LoadFactor**（负载因子），当 `count > LoadFactor * 2^B` 或 overflow bucket 过多时，Go 运行时会对 map 进行扩容。目前 LoadFactor 设置为 6.5。

- 如果是因为 overflow bucket 过多导致的“扩容”，实际上运行时会新建一个和现有规模一样的 bucket 数组，然后在进行 assign 和 delete 操作时进行排空和迁移；
- 如果是因为当前数据数量超出 LoadFactor 指定的水位的情况，那么运行时会建立一个**两倍于现有规模的 bucket 数组**，但真正的排空和迁移工作也是在进行 assign 和 delete 操作时住不进行的。原 bucket 数组会挂在 hmap 的 oldbuckets 指针下面，直到原 buckets 数组中所有数据都迁移到新数组，原 buckets 数组才会被释放。

### map 与并发

充当 map 描述符角色的 hmap 实例自身是有状态的（hmap.flags）且对状态的读写是没有并发保护的，因此 **map 实例不是并发写安全的，不支持并发读写**。

- 如果对 map 实例进行并发读写，程序运行时会发生 panic。
- 如果仅仅是并发读，则 map 是没有问题的。
- Go1.9 版本中引入了支持并发写安全的 **sync.Map** 类型，可以用来在并发读写的场景下替换掉 map。
- 另外考虑到 map 可以自动扩容，map 中数据元素的 value 位置可能在这一过程中发生变化，因此 Go **不允许读取 map 中 value 的地址**，这个约束是在编译期间就生效的。

### 尽量使用 cap 参数创建 map

如果初始创建 map 时没有创建足够多可以应付 map 使用场景的 bucket，那么随着插入 map 元素数量的增多，map 会频繁扩容，而这一过程将降低 map 的访问性能，因此，**如果可能的话，我们最好对 map 使用规模做出粗略的估算，并使用 cap 参数对 map 实例进行初始化**。

## 15 了解 string 实现原理并高效使用

### string 功能特点

Go 的 string 类型设计充分吸取了 C 语言字符串设计的经验教训，并结合了其他主流语言字符串类型设计上的最佳实践，具有如下功能特点：

- string 类型的数据是**不可变**的。如果将 string 转为 byte 切片修改，Go 编译器会为切片变量重新分配底层存储而不是共用 string 的底层存储；如果直接通过指针修改内存中存储的数据，会得到 SIGBUS 的运行时错误，因为只能对 string 的底层数据存储区进行只读操作。
- 零值可用。零值为""，长度为 0。
- 获取长度的时间复杂度是 O(1) 级别。
- 支持通过 +/+= 操作符进行字符串连接。
- 支持各种比较关系操作符：==、!=、>=、<=、>、<。如果两字符串长度不相同，则可断定字符串不同；如果长度相同，进一步判断数据指针是否指向同一块底层存储数据；如果相同则两字符串是等价的；如果不同，则需进一步对比实际的数据内容。
- 对非 ASCII 字符提供原生支持。Go 语言源文件默认采用 Unicode 字符集。
- 原生支持多行字符串。直接提供了通过反引号构造“所见即所得”的多行字符串。

### string 底层实现

Go string 在运行时表示为下面的结构：

```Go
type stringStruct struct {
   str unsafe.Pointer
   len int
}
```

可以看到 string 类型也是一个**描述符**，它本身并不真正存储数据，而仅是一个指向底层存储的指针和字符串的长度字段组成。实例化一个字符串对应的函数：

```Go
func rawstring(size int) (s string, b []byte) {
   p := mallocgc(uintptr(size), nil, false)

   stringStructOf(&s).str = p
   stringStructOf(&s).len = size

   *(*slice)(unsafe.Pointer(&b)) = slice{p, size, size}

   return
}
```

每个字符串类型变量/常量对应一个 stringStruct 实例，经过 rawstring 实例化后，stringStruct 中的 str 指针指向真正存储字符串数据的底层内存区域，len 字段存储的是字符串的长度；rawstring 同时还创建了一个临时 slice，该 slice 的 array 指针也指向存储字符串数据的底层内存区域。注意，rawstring 调用后，新申请的内存区域还未被写入数据，该 slice 就是供后续运行时层向其中写入数据用的，写完数据后，该 slice 就可以被回收掉了。

根据 string 在运行时的表示可以得到结论：直接将 string 类型通过函数/方法参数传入也不会有太多的损耗，因为传入的仅仅是一个“描述符”，而不是真正的字符串数据。

### 字符串的高效构造

Go 原生支持通过 +/+= 操作符来连接多个字符串以构造一个更长的字符串，但 Go 还提供了其他一些构造字符串的方法：

- fmt.Sprintf
- strings.Join
- Strings.Builder
- Bytes.Buffer

通过一个[字符串连接基础测试](https://github.com/XQ-Gang/learnGo/blob/main/example/string_concat_benchmark_test.go)可以得出一些结论：

- 在能**预估出最终字符串长度**的情况下，使用预初始化的 **strings.Builder** 连接构建字符串效率最高；
- **strings.Join** 连接构建字符串的**平均性能最稳定**，如果输入的多个字符串是以 []string 承载的，那么 strings.Join 也是不错的选择；
- **使用操作符**连接的方式最直观、最自然，在**编译器知晓欲连接的字符串个数**的情况下，使用此种方式可以得到编译器的优化处理；
- **fmt.Sprintf** 虽然效率不高，但也不是一无是处，如果是**由多种不同类型变量来构建特定格式的字符串**，那么这种方式还是最适合的。

### 字符串相关的高效转换

string 和 []rune、[]byte 可以双向转换。

无论是 string 转 slice 还是 slice 转 string，转换都是要付出代价的，这些代价的根源在于 string 是不可变的，运行时要为转换后的类型分配新内存。

想要更高效地进行转换，唯一的方法就是**减少甚至避免额外的内存分配操作**。运行时实现转换的函数中已经加入了一些避免每种情况都要分配新内存操作的优化。

slice 类型是不可比较的，而 string 类型是可比较的，因此在日常 Go 编码中，我们会经常遇到将 slice 临时转换为 string 的情况。Go 编译器为这样的场景提供了优化：

```Go
func slicebytetostringtmp(ptr *byte, n int) (str string) {
   if raceenabled && n > 0 {
      racereadrangepc(unsafe.Pointer(ptr),
         uintptr(n),
         getcallerpc(),
         abi.FuncPCABIInternal(slicebytetostringtmp))
   }
   if msanenabled && n > 0 {
      msanread(unsafe.Pointer(ptr), uintptr(n))
   }
   if asanenabled && n > 0 {
      asanread(unsafe.Pointer(ptr), uintptr(n))
   }
   stringStructOf(&str).str = unsafe.Pointer(ptr)
   stringStructOf(&str).len = n
   return
}
```

该函数的秘诀就在于不为 string 新开辟一块内存，而是直接使用 slice 的底层存储。当然使用这个函数的前提是：**在原 slice 被修改后，这个 string 不能再被使用了**。因此这样的优化是针对以下几个特定场景的：

- string(b) 用在 map 类型的 key 中

  ```Go
  b := []byte{'k', 'e', 'y'}
  m := make(map[string]string)
  m[string(b)] = "value"
  ```

- string(b) 用在字符串连接语句中

  ```Go
  b := []byte{'w', 'o', 'r', 'l', 'd'}
  s := "hello " + string(b) + "!"
  ```

- string(b) 用在字符串比较中

  ```Go
  b := []byte{'w', 'o', 'r', 'l', 'd'}
  s := "world"
  if s < string(b) {
     ...
  }
  ```

Go 编译器对用在 for-range 循环中的 string 到 []byte 的转换也有优化处理，它不会为 []byte 进行额外的内存分配，而是直接使用 string 的底层数据：

```Go
// Go 编译器优化，可以节省一次内存分配操作
s := "world"
for _, v := range []byte(s) {
   _ = v
}
```

此外，Go 语言还在标准库中提供了 strings 和 strconv 包，可以辅助 Gopher 对 string 类型数据进行更多高级操作。

## 参考

《Go 语言精进之路：从新手到高手的编程思想、方法和技巧》——白明