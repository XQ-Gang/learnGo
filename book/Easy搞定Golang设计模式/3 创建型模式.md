# 三、创建型模式

https://www.yuque.com/aceld/lfhu8y/om200u?inner=LNfx5

## 3.1 简单工厂模式

通过专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。

**工厂（Factory）角色**：简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象。

**抽象产品（AbstractProduct）角色**：简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。

**具体产品（Concrete Product）角色**：简单工厂模式所创建的具体实例对象。

![img](https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1656403534138-1ecc2052-e671-46b8-b2f0-b3e987f1a012.jpeg)

优点：

1. 实现了对象创建和使用的分离。
2. 不需要记住具体类名，记住参数即可，减少使用者记忆量。

缺点：

1. 对工厂类职责过重，一旦不能工作，系统受到影响。
2. 增加系统中类的个数，复杂度和理解度增加。
3. 违反“开闭原则”，添加新产品需要修改工厂逻辑，工厂越来越复杂。

适用场景：

1. 工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。
2. 客户端只知道传入工厂类的参数，对于如何创建对象并不关心。

## 3.2 工厂方法模式

定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中。

**抽象工厂（Abstract Factory）角色**：工厂方法模式的核心，任何工厂类都必须实现这个接口。

**工厂（Concrete Factory）角色**：具体工厂类是抽象工厂的一个实现，负责实例化产品对象。

**抽象产品（Abstract Product）角色**：工厂方法模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。	

**具体产品（Concrete Product）角色**：工厂方法模式所创建的具体实例对象。

![img](https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1656405767817-943d9712-38ca-473a-bbe1-d7393b284879.jpeg)

优点：

1. 不需要记住具体类名，甚至连具体参数都不用记忆。
2. 实现了对象创建和使用的分离。
3. 系统的可扩展性也就变得非常好，无需修改接口和原类。
4. 对于新产品的创建，符合开闭原则。

缺点：

1. 增加系统中类的个数，复杂度和理解度增加。
2. 增加了系统的抽象性和理解难度。

适用场景：

1. 客户端不知道它所需要的对象的类。
2. 抽象工厂类通过其子类来指定创建哪个对象。

## 3.3 抽象工厂方法模式

提供一个创建一系列相关或者相互依赖的接口，而无需指定它们具体的类。

**产品族**：具有同一个地区、同一个厂商、同一个开发包、同一个组织模块等，但是具备不同特点或功能的产品集合，称之为是一个产品族。

**产品等级结构**：具有相同特点或功能，但是来自不同的地区、不同的厂商、不同的开发包、不同的组织模块等的产品集合，称之为是一个产品等级结构。

当程序中的对象可以被划分为产品族和产品等级结构之后，那么“抽象工厂方法模式”才可以被适用。

**抽象工厂（Abstract Factory）角色**：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。

**具体工厂（Concrete Factory）角色**：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。

**抽象产品（Abstract Product）角色**：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。

**具体产品（Concrete Product）角色**：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。

![img](https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1656499122737-301b32c4-00ef-41cd-850b-a567380f5030.jpeg)

优点：

1. 拥有工厂方法模式的优点
2. 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。
3. 增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。

缺点：

1. 增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”。

适用场景：

1. 系统中有多于一个的产品族。而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族。
2. 产品等级结构稳定。设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。

## 3.4 单例模式

是保证一个类仅有一个实例，并提供一个访问它的全局访问点。

**Singleton（单例）**：在单例类的内部实现只生成一个实例，同时它提供一个静态的getInstance()工厂方法，让客户可以访问它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有；在单例类内部定义了一个Singleton类型的静态对象，作为外部共享的唯一实例。

![img](https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1656571484968-7f76261e-b135-4ad5-a1d0-4607ea2d316f.jpeg)

优点：

1. 单例模式提供了对唯一实例的受控访问。
2. 节约系统资源。由于在系统内存中只存在一个对象。    

缺点：

1. 扩展略难。单例模式中没有抽象层。
2. 单例类的职责过重。   

适用场景：

1. 系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象。
2. 客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。

## 参考

《Easy 搞定 Golang设计模式》——刘丹冰Aceld
