# 异常处理

## 8.1 error

- 如果不需要格式化字符串，尽量使用 erros.New()，否则使用 fmt.Errorf()
- errors.Unwrap() 方法遇到无法拆解的 error 时直接返回nil
- errors.Is() 用于检查特定的 error 链中是否包含指定的 error 值
- errors.As() 用于从一个 error 链中查找是否有指定的类型出现，如有，则把 error 转换成该类型

## 8.2 defer

- 延迟函数的参数在 defer 语句出现时就已经确定了，实际上是复制了一份参数
- 每申请到一个用完需要释放的资源时，立即定义一个 defer 来释放资源
- 延迟函数可能操作主函数的具名返回值
- return 不是原子操作，执行过程是：保存返回值（若有）->执行defer（若有）->执行ret跳转
- defer 实现原理：编译器会把每个延迟函数编译成一个 _defer 实例，多个 _defer 实例使用指针 link 链接起来形成一个单链表，暂存到 goroutine 数据结构中。
- defer 的三种类型：
  - heap-allocated：堆defer。编译器将 defer 语句编译成一个 deferproc() 函数调用，然后运行时执行 deferproc 函数，deferproc 函数会根据 defer 语句生成一个 \_defer 实例并插入 goroutine 的 \_defer 链表头部。同时编译器还会在函数尾部插入 deferreturn 函数，deferreturn 函数会逐个取出 \_defer 实例并执行。特点是新创建的 defer 节点存储在堆中，deferreturn 函数消费完 \_defer 后，再将节点销毁。痛点在于频繁的堆内存分配及释放，性能较差。
  - stack-allocated：栈defer。编译器会直接在栈上预留 _defer 的存储空间，deferprocStack() 不需要再分配空间。但由于栈空间也有限，并不能把所有的 defer 都存储在栈中，所以还需要保留堆 defer。
  - open-coded：开放编码defer。编译器完成 defer 语句的预处理，延迟函数被直接插入函数尾部，运行时不需要参与预处理 defer。但是以下场景下 defer 语句不能被处理成开放编码类型：
    - 编译时禁用了编译器优化，即`-gcflags="-N -1"`。
    - defer 出现在循环语句中。
    - 单个函数中 defer 出现 8 个及以上，或者 return 语句个数和 defer 语句个数乘积超过了 15。
- 单个函数中如果存在过多的 defer，那么可以考虑拆分函数
- 单个函数中如果存在过多的 return，那么需要控制 defer 的使用数量
- 再循环中使用 defer 语句需要慎重


## 参考

《Go 专家编程》——任洪彩