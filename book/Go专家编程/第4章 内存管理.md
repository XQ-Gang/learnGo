# 内存管理

## 4.1 内存分配

- Go 的内存分配器原理与 tcmalloc 类似 ，简单地说就是维护一块大的全局内存，每个线程（Go 中为处理器 P）维护一块小的私有内存，私有内存不足时再从全局申请。
-  Go 程序启动时申请一大块内存，并划分成 spans、bitmap、arena 区域
  - arena 区域按页划分成一个个小块
  - span 管理一个或多个页
  - mcentral 管理多个 span 供线程申请使用
  - mcache 作为线程私有资源，资源来源于 mcentral

## 4.2 垃圾回收

- 简单来说，垃圾回收的核心就是标记出哪些内存还在使用中（即被引用到），哪些内存不再使用了（即未被引用），把未被引用的内存回收，以供后续内存分配时使用。
- STW 的目的是防止 GC 扫描时内存变化而停止 goroutine
- 垃圾回收优化
  - 写屏障：让 goroutine 与 GC 同时运行的手段，大大缩短 STW 时间。类似一种开关，在 GC 特定时机开启，开启后指针传递时会标记指针，即本轮不回收，下次 GC 时再确定。GC 过程中新分配的内存会被立即标记，即 GC 过程中分配的内存不会在本轮 GC 中回收。
  -  辅助 GC：防止内存分配过快，在 GC 执行过程中，如果 goroutine 需要分配内存，那么该 goroutine 会参与一部分 GC 的工作，即帮助做一部分工作，这个机制叫做 Mutator Assistant。
- 垃圾回收的触发时机
  - 内存分配量达到阈值（GOGC 控制，默认每当内存扩大一倍时）触发 GC
  - 定期触发 GC（默认最长 2 分钟触发一次 GC）
  - 手动触发（runtime.GC()）
- GC 性能优化
  - 减少对象分配的个数，比如对象复用或使用大对象组合多个小对象，等等。
  - 内存逃逸现场会产生一些隐式的内存分配，也有可能成为 GC 的负担。

## 4.3 逃逸分析

- 逃逸分析是指由编译器决定内存分配的位置，不需要程序员指定，在函数中申请一个新的对象：
  - 如果分配在栈中，则函数执行结束后可自动将内存回收（不需要 GC 处理）
  - 如果分配在堆中，则函数执行结束后可交给 GC 处理
- 逃逸分析在**编译阶段**完成
- 逃逸分析的目的是**决定分配地址是栈还是堆**
- 栈上分配内存比在堆中分配内存有更高的效率
- 逃逸策略
  - 如果函数外部没有引用，则优先放在栈中
  - 如果函数外部存在引用，则必定放在堆中
  - 对于仅在函数内部使用的变量，也有可能放在堆中，如内存过大超过栈的存储能力
- 逃逸场景
  - 指针逃逸
  - 栈空间不足逃逸
  - 动态类型逃逸（interface 类型，如 fmt.Println），编译期间很难确定其参数的具体类型
  - 闭包引用对象逃逸
- 思考：传递指针可以减少底层值的复制，可以提高效率，但是如果复制的数据量小，由于指针传递会产生逃逸，则可能会使用堆，也可能增加 GC 的负担，所以传递指针不一定是高效的。

## 参考

《Go 专家编程》——任洪彩
