# 内存管理

## 4.1 内存分配

- Go 的内存分配器原理与 tcmalloc 类似 ，简单地说就是维护一块大的全局内存，每个线程（Go 中为处理器 P）维护一块小的私有内存，私有内存不足时再从全局申请。
-  Go 程序启动时申请一大块内存，并划分成 spans、bitmap、arena 区域
  - arena 区域按页划分成一个个小块
  - span 管理一个或多个页
  - mcentral 管理多个 span 供线程申请使用
  - mcache 作为线程私有资源，资源来源于 mcentral

## 4.2 垃圾回收

- 简单来说，垃圾回收的核心就是标记出哪些内存还在使用中（即被引用到），哪些内存不再使用了（即未被引用），把未被引用的内存回收，以供后续内存分配时使用。
- STW 的目的是防止 GC 扫描时内存变化而停止 goroutine
- 垃圾回收优化
  - 写屏障：让 goroutine 与 GC 同时运行的手段，大大缩短 STW 时间。类似一种开关，在 GC 特定时机开启，开启后指针传递时会标记指针，即本轮不回收，下次 GC 时再确定。GC 过程中新分配的内存会被立即标记，即 GC 过程中分配的内存不会在本轮 GC 中回收。
  -  辅助 GC：防止内存分配过快，在 GC 执行过程中，如果 goroutine 需要分配内存，那么该 goroutine 会参与一部分 GC 的工作，即帮助做一部分工作，这个机制叫做 Mutator Assistant。
- 垃圾回收的触发时机
  - 内存分配量达到阈值（GOGC 控制，默认每当内存扩大一倍时）触发 GC
  - 定期触发 GC（默认最长 2 分钟触发一次 GC）
  - 手动触发（runtime.GC()）
- GC 性能优化
  - 减少对象分配的个数，比如对象复用或使用大对象组合多个小对象，等等。
  - 内存逃逸现场会产生一些隐式的内存分配，也有可能成为 GC 的负担。

## 参考

《Go 专家编程》——任洪彩
