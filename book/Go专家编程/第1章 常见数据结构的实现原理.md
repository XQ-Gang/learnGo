# 常见数据结构的实现原理

## 1.1 管道

内置函数 len() 和 cap() 作用于管道，分别用于查询缓冲区数据的个数及缓冲区的大小。

管道实现了一种 FIFO 的队列，数据总是按照写入的顺序流出管道。

协程读取管道时，阻塞的条件有：

- 管道无缓冲区；
- 管道的缓冲区中无数据；
- 管道的值为 nil；

协程写入管道时，阻塞的条件有：

- 管道无缓冲区；
- 管道的缓冲区已满；
- 管道的值为 nil；

管道的数据结构：

```Go
// $GOROOT/src/runtime/chan.go
type hchan struct {
   qcount   uint           // 当前队列中剩余的元素个数
   dataqsiz uint           // 环形队列长度，即可以存放的元素个数
   buf      unsafe.Pointer // 环形队列指针
   elemsize uint16         // 每个元素的大小
   closed   uint32         // 表示关闭状态
   elemtype *_type         // 元素类型
   sendx    uint           // 队列下标，指示元素写入时存放到队列中的位置
   recvx    uint           // 队列下标，指示下一个被读取的元素在队列中的位置
   recvq    waitq          // 等待读消息的协程队列
   sendq    waitq          // 等待写消息的协程队列
   lock mutex              // 互斥锁，chan 不允许并发读写
}
```

chan 内部实现了一个环形队列作为其缓冲区，队列的长度是在创建 chan 时指定的。

从管道读取数据时，如果管道缓冲区为空或没有缓冲区，则当前协程会被阻塞，并被加入 recvq 队列。向管道写入数据时，如果管道缓冲区已满或者没有缓冲区，则当前协程会被阻塞，并被加入 sendq 队列。

处于等待队列中的协程会在其他协程操作管道时被唤醒：

- 因读阻塞的协程会被向管道写入数据的协程唤醒；
- 因写阻塞的协程会被从管道读取数据的协程唤醒。

一般情况下 recvq 和 sendq 至少有一个为空。只有一个例外，那就是同一个协程使用 select 语句向管道一边写入数据，一边读取数据，此时协程会分别位于两个等待队列中。

互斥锁：一个管道同时仅允许被一个协程读写。

常见用法：单向管道、select case、for-range

## 1.2 slice

- 声明长度为 0 的切片时，推荐使用变量声明的方式获得一个 nil 切片，而不是空切片，因为 nil 切片不需要内存分配。
- 推荐指定长度的同时指定预估空间，可有效地减少切片扩容时内存分配及拷贝次数。
- 扩容容量的选择遵循以下原则：
  - 如果原 slice 的容量小于 1024，则新 slice 的容量将扩大为原来的 2 倍；（减少内存分配的次数和数据拷贝的代价）
  - 如果原 slice 的容量大于或等于 1024，则新 slice 的容量将扩大为原来的 1.25 倍。（避免浪费空间）
- 切片拷贝时需要判断实际拷贝的元素个数，拷贝数量取两个切片长度的最小值。
- 通过函数传递切片时，不会拷贝整个切片，因为切片本身只是一个结构体而已。
- 使用 append() 向切片追加元素时有可能触发扩容，扩容后会生成新的切片。

## 1.3 map

- 避免并发读写 map，如果需要并发读写，则可以使用额外的锁（互斥锁、读写锁），也可以考虑使用标准库 sync 包中的 sync.Map。

- map 的数据结构：

  ```Go
  type hmap struct {
     count     int    // 当前保存的元素个数
     flags     uint8
     B         uint8  // bucket 数组的大小
     noverflow uint16
     hash0     uint32
  
     buckets    unsafe.Pointer // bucket 数组，数组的长度为 2^B
     oldbuckets unsafe.Pointer // 老旧 bucket 数组，用于扩容
     nevacuate  uintptr
  
     extra *mapextra
  }
  
  type bmap struct {
  	tophash [8]uint8
  }
  
  ```

  元素经过 Hash 运算后会落到某个 bucket 中进行存储。

- Hash 冲突：Go 使用链地址法来解决键冲突。由于每个 bucket 可以存放 8 个键值对，所以同一个 bucket 存放超过 8 个键值对时就会再创建一个 bucket，用类似链表的方式将 bucket 连接起来。

- 负载因子：键数量/bucket 数量，Go 的 map 在负载因子达到 6.5 是会触发 rehash。

## 1.4 struct

- omitempty 表示字段转换成 JSON 字符串时如果字段为空则省略。
- Go 语言的反射特性可以动态地给结构体成员赋值。

## 1.5 iota

- 单个 const 声明块中从 0 开始取值
- 单个 const 声明块中，每增加一行声明，iota 的取值增 1，即便声明中没有使用 iota 也是如此
- 单行声明语句中，即便出现多个 iota，iota 的取值也保持不变

## 1.6 string

- string 不包含内存空间，只有一个内存的指针，这使得 string 非常轻量，很方便进行传递而不用担心内存拷贝
- string 通常指向字符串字面量，而字符串字面量存储的位置是只读段，而不是堆或栈上
- 编译优化：临时需要字符串的场景下（如使用 m[string(b)] 来查找 map、字符串拼接、字符串比较时），byte 切片转换成 string 时并不会拷贝内存，而是直接返回一个 string，这个 string 的指针指向切片的内存。

## 参考

《Go 专家编程》——任洪彩
