# 并发控制

## 5.1 channel

- channel 一般用于协程之间的通信，不过也可以用于并发控制。比如主协程启动 N 个子协程，主协程等待所有子协程退出后再继续后续流程。
- 使用 channel 控制子协程的优点是实现简单，缺点是当需要大量创建协程时就需要有相同数量的 channel，而且对于子协程继续派生出来的协程不方便控制。

## 5.2 WaitGroup

- WaitGroup 的实现使用了信号量
- 信号量是 UNIX 系统提供的一种保护共享资源的机制，用于防止多个线程同时访问某个资源
  - 当信号量>0 时，表示资源可用，获取信号量时系统自动将信号量减 1
  - 当信号量==0 时，表示资源暂不可用，获取信号量时，当前线程会进入睡眠，当信号量为正时被唤醒
- WaitGroup 结构体包含 state（两个计数器）和一个信号量
  - counter：当前还未执行结束的 goroutine 计数器
  - waiter count：等待 goroutine-group 结束的 goroutine 数量，即有多少个等待者
  - semaphore：信号量
- Add() 操作必须早于 Wait()， 否则会触发 panic
- Add() 设置的值必须与实际等待的 goroutine 的个数一致，否则会触发 panic

## 5.3 context

- context 对于派生 goroutine 有更强的控制力，它可以控制多级的 goroutine
- Context 仅仅是一个接口定义，根据实现的不同，可以衍生出不同类型的 context
- cancelCtx 实现了 Context 接口，通过 WithCancel() 创建 cancelCtx 实例
- timerCtx 实现了 Context 接口，通过 WithDeadline() 和 WithTimeout() 创建 timerCtx 实例
- valueCtx 实现了 Context 接口，通过 WithValue() 创建 valueCtx 实例
- 三种 context 实例可互为父节点，从而可以组合成不同的应用形式

## 参考

《Go 专家编程》——任洪彩
