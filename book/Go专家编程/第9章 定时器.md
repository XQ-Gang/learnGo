# 定时器

## 9.1 一次性定时器（Timer）

- 使用场景：

  - 设定超时时间
  - 延迟执行某个方法

  ```go
  func WaitChannel(conn <-chan string) bool {
  	timer := time.NewTimer(time.Second)
  	select {
  	case <-conn:
  		timer.Stop()
  		return true
  	case <-timer.C: // 超时
  		println("WaitChannel timeout!")
  		return false
  	}
  }
  ```

- 仅等待指定时间 `time.After`：

  ```go
  func AfterDemo() {
  	fmt.Println(time.Now())
  	<-time.After(time.Second)
  	fmt.Println(time.Now())
  }
  ```

- 等待指定时间后执行函数f `time.AfterFunc`：

  ```go
  func AfterFuncDemo() {
  	fmt.Println(time.Now())
  	time.AfterFunc(time.Second, func() {
  		fmt.Println(time.Now())
  	})
  	time.Sleep(time.Second * 2)
  }
  ```

- 原理：一个进程中的多个 Timer 都由底层的协程（系统协程）来管理，runtimeTimer 存放在数组中，并按照 when 字段对所有的 runtimeTimer 进行堆排序，定时器触发时执行 runtimeTimer 中的预定义函数 f，即完成了一次定时任务。

  ```go
  func NewTimer(d Duration) *Timer {
  	c := make(chan Time, 1)
  	t := &Timer{
  		C: c,
  		r: runtimeTimer{
  			when: when(d),   // 触发时间
  			f:    sendTime,  // 触发后执行 sendTime 函数
  			arg:  c,         // 触发后执行 sendTime 函数时附带的参数
  		},
  	}
  	startTimer(&t.r)         // 启动定时器，把 runtimeTimer 放到系统协程的堆中，由系统协程维护
  	return t
  }
  
  func sendTime(c any, seq uintptr) {
  	select {
  	case c.(chan Time) <- Now():
  	default:
  	}
  }
  ```


## 参考

《Go 专家编程》——任洪彩