# 控制结构

## 2.1 select

- 管道关闭后仍可读取数据
- 空的 select 语句会永久阻塞
- 使用场景
  - 永久阻塞：启动协程处理任务，并且不希望 main 函数退出
  - 快速检错：使用管道传输错误，快速检查管道中是否有错误，避免陷入循环
  - 限时等待：创建只有一定时效的定时器管道，管理函数上下文
- Runtime 包中提供了 selectgo() 方法处理 select 语句
  - 通过随机函数 fastrandn() 将原始的 case 顺序打乱，在遍历各个 case 时使用打乱后的顺序就会表现出**随机**性。
  - 循环遍历各个 case 时，如果发现某个 case 就绪（管道可读或可写），则直接跳出循环进行管道操作并返回。
  - 循环变量遍历各个 case 时，循环能正常结束（没有跳转），说明所有 case 都没有就绪，如果有 default 语句则命中 default。
  - 如果所有 case 都未命中且没有 default，selectgo() 将阻塞等待所有管道，任一管道就绪后，都将开始新的循环。

## 2.2 for-range

- 使用`for _, v := range s { v ... }`时，遍历过程中每次迭代均会执行一次赋值操作，赋值涉及内存拷贝，性能上不如使用切片下标`for i := range s { s[i] ... }`。
- 迭代变量只会声明一次，在多次迭代中共享，循环速度快于协程启动速度。
- for-range 遍历值为 nil 的 channel 时会永久阻塞。
- for-range 表达式作用于 channel 时，会遍历 channel 中的所有元素，如果没有元素则会阻塞等待，直到 channel 被关闭。
- 作用于数组、切片时，循环次数在循环开始前已经确定为数组长度，在循环过程中，数组中新添加的元素是无法遍历到的。
- 作用于 map 时，插入数据位置是随机的，所以遍历过程中新插入的数据不能保证遍历到。
- 尽量避免在遍历过程中修改原数据。

## 参考

《Go 专家编程》——任洪彩
