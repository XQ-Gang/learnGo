# 协程

## 3.1 协程的概念

- 基本概念
  - 进程：进程是应用程序的启动实例，每个进程都有独立的内存空间，不同进程通过进程间的通信方式来通信。
  - 线程：线程从属于进程，每个进程至少包含一个线程，线程是 CPU 调度的基本单位，多个线程之间可以共享进程的资源并通过共享内存等线程间的通信方式来通信。
  - 协程：协程可理解为一种轻量级线程，与线程相比，协程不受操作系统调度，协程调度器由用户应用程序提供，协程调度器按照调度策略把协程调度到线程中运行。Go 应用程序的协程调度器由 runtime 包提供，用户使用 go 关键字即可创建协程，这也就是在语言层面直接支持协程的含义。
- 线程池下，如果 woker 线程执行的 G 任务发生系统调用，则操作系统会将该线程置为阻塞状态，大部分 worker 线程进入阻塞状态，会使得任务队列中的任务产生堆积。增加线程池中的线程数量可以在一定程度上提高消费能力，但随着线程数量增多，过多线程争抢 CPU 资源，消费能力会有上限。而且过多的线程会导致上下文切换的开销变大。

## 3.2 调度模型

- Go 实现 M:N 模型，M 个用户协程运行在 N 个线程中，充分利用 CPU 的算力，且协程上下文切换快。
- 调度策略
  - 队列轮转：依次处理本地队列，周期性查看全局队列（防止长时间得不到调度而被饿死）。
  - 系统调用：M0 释放 P，M0 由于陷入系统调用而被阻塞，M1 接替 M0 工作，G0 结束系统调用后，如有空闲 P，则换取 P 继续执行 G0，否则 G0 放入全局队列等待调度。M0 进入缓存池。
  - 工作量窃取：P 在没有协程需要调度时会查询全局队列，如果也没有，则会从另一个正在运行的处理器 P 中偷取协程，每次偷取一半。
  - 抢占式调度：Go1.14 引入基于信号的抢占机制。
  - GOMAXPROCS：Go 调度器检测到 M 被阻塞是有一定延迟的，即旧的 M 被阻塞和新的 M 得到运行之间是有一定间隔的，所以在 I/O 密集型应用中调大 GOMAXPROCS，或许会有好的效果。

## 参考

《Go 专家编程》——任洪彩
