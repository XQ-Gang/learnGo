# 编程陷阱

格外关注以下错误：

- 切片扩容：append() 可能会生成新的切片，谨慎地处理返回值
- 空切片：append() 可能会追加 nil 值，避免追加无意义的元素
- append 的本质：`func append(slice []Type, elems ...Type) []Type`，入参为切片，而切片只是一个 struct 结构，参数传递时发生了值拷贝，所以 append 无法操作原切片
- 循环变量引用：如果需要以指针的形式存放循环变量，则可以显式地拷贝一次；或者修改切片的类型，避免存储指针
- 协程引用循环变量：当循环中引用循环变量时，如果需要启动并发并且引用循环变量，则需要格外留意变量是否已绑定
- recover 失效：以下三个条件会让 recover() 返回 nil：
  - panic(nil)
  - 当前协程没有发生 panic
  - recover 没有被 defer 函数**直接调用**（recover 不应被单独封装函数）


## 参考

《Go 专家编程》——任洪彩